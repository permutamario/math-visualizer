"use strict";(self.webpackChunkmath_visualizer_react=self.webpackChunkmath_visualizer_react||[]).push([[601],{1601:(e,t,i)=>{i.r(t),i.d(t,{default:()=>p});var r=i(4705),n=i(9379),s=i(2834);class o extends s.j{constructor(e){super(e),"2d"!==this.renderingType&&(console.warn("Plugin ".concat(this.id," should have renderingType='2d'")),this.renderingType="2d"),this._shapes=new Map,this._groups=new Map,this._eventBindings=[],this._layers={background:null,grid:null,main:null,overlay:null,animation:null},this._nextShapeId=1}getLayer(e){if(this._layers[e])return this._layers[e];if(!this.renderEnv||!this.renderEnv.stage)return console.error("Rendering environment not initialized"),null;const t=this.renderEnv.stage.getLayers().find((t=>t.name()===e));if(t)return this._layers[e]=t,t;const i=this.renderEnv.konva;if(!i)return console.error("Konva not available in rendering environment"),null;const r=new i.Layer({name:e}),n=["background","grid","main","overlay","animation"],s=n.indexOf(e);if(-1===s)this.renderEnv.stage.add(r);else{const e=this.renderEnv.stage.getLayers();let t=!1;for(let i=s+1;i<n.length;i++){const s=n[i],o=e.find((e=>e.name()===s));if(o){r.moveToTop(),o.moveToTop(),t=!0;break}}t||this.renderEnv.stage.add(r)}return this._layers[e]=r,r}_createUniqueId(){return"shape_".concat(this.id,"_").concat(this._nextShapeId++)}_registerShape(e,t){return e.id()&&""!==e.id()||e.id(this._createUniqueId()),this._shapes.set(e.id(),{shape:e,layerName:t}),e}addShape(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"main";const i=this.getLayer(t);return i?(i.add(e),this._registerShape(e,t)):null}addGroup(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"main";const i=this.getLayer(t);return i?(i.add(e),this._groups.set(e.id()||this._createUniqueId(),{group:e,layerName:t}),e):null}_createShape(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main";if(!this.renderEnv||!this.renderEnv.konva)return console.error("Konva not available in rendering environment"),null;const r=this.renderEnv.konva;let s;switch(e.toLowerCase()){case"rect":s=new r.Rect(t);break;case"circle":s=new r.Circle(t);break;case"ellipse":s=new r.Ellipse(t);break;case"line":s=new r.Line(t);break;case"path":s=new r.Path(t);break;case"text":s=new r.Text(t);break;case"regularpolygon":s=new r.RegularPolygon(t);break;case"star":s=new r.Star(t);break;case"image":s=new r.Image(t);break;case"polygon":s=new r.Line((0,n.A)((0,n.A)({},t),{},{closed:!0}));break;case"group":return this.createGroup(i);default:return console.error("Unknown shape type: ".concat(e)),null}return this.addShape(s,i)}createRect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"main";return this._createShape("rect",e,t)}createCircle(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"main";return this._createShape("circle",e,t)}createLine(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"main";return this._createShape("line",e,t)}createPolygon(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"main";return this._createShape("polygon",e,t)}createText(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"main";return this._createShape("text",e,t)}createPath(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"main";return this._createShape("path",e,t)}createImage(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"main";return this._createShape("image",e,t)}createGroup(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"main";const t=this.renderEnv.konva;if(!t)return console.error("Konva not available in rendering environment"),null;const i=new t.Group({id:this._createUniqueId()});return this.addGroup(i,e)}redrawLayer(e){const t=this.getLayer(e);t&&"function"===typeof t.batchDraw&&t.batchDraw()}redrawAllLayers(){for(const e in this._layers)this._layers[e]&&this.redrawLayer(e)}addEventHandler(e,t,i){return e&&"function"===typeof e.on?(e.on(t,i),this._eventBindings.push({shape:e,eventType:t,handler:i}),!0):(console.error("Invalid shape for event handler"),!1)}removeEventHandler(e,t,i){if(!e||"function"!==typeof e.off)return!1;e.off(t,i);const r=this._eventBindings.findIndex((r=>r.shape===e&&r.eventType===t&&r.handler===i));return-1!==r&&(this._eventBindings.splice(r,1),!0)}refresh(){this.redrawAllLayers()}async unload(){try{return this._shapes.forEach((e=>{let{shape:t,layerName:i}=e;t&&"function"===typeof t.destroy&&t.destroy()})),this._shapes.clear(),this._groups.forEach((e=>{let{group:t,layerName:i}=e;t&&"function"===typeof t.destroy&&t.destroy()})),this._groups.clear(),this._eventBindings.forEach((e=>{e.shape&&"function"===typeof e.shape.off&&e.shape.off(e.eventType,e.handler)})),this._eventBindings=[],this._layers={background:null,grid:null,main:null,overlay:null,animation:null},await super.unload()}catch(e){return console.error("Error unloading 2D plugin ".concat(this.id,":"),e),!1}}}class a{constructor(e,t){this.rows=e,this.cols=t,this.gridLines=new Map,this.usedDirections=new Map,this.initializeGridLines(),this.computeConnections(),this.placeBoundaryMirrors(),this.initializeUsedDirections()}initializeGridLines(){for(let e=0;e<=this.rows;e++)for(let t=0;t<this.cols;t++){const i=this.generateGridLineId("h",e,t);this.gridLines.set(i,{id:i,type:"horizontal",row:e,col:t,isMirror:!1,connections:{[a.NW]:null,[a.NE]:null,[a.SW]:null,[a.SE]:null}})}for(let e=0;e<this.rows;e++)for(let t=0;t<=this.cols;t++){const i=this.generateGridLineId("v",e,t);this.gridLines.set(i,{id:i,type:"vertical",row:e,col:t,isMirror:!1,connections:{[a.NW]:null,[a.NE]:null,[a.SW]:null,[a.SE]:null}})}}placeBoundaryMirrors(){for(let e=0;e<this.cols;e++){const t=this.generateGridLineId("h",0,e);this.setMirror(t,!0)}for(let e=0;e<this.cols;e++){const t=this.generateGridLineId("h",this.rows,e);this.setMirror(t,!0)}for(let e=0;e<this.rows;e++){const t=this.generateGridLineId("v",e,0);this.setMirror(t,!0)}for(let e=0;e<this.rows;e++){const t=this.generateGridLineId("v",e,this.cols);this.setMirror(t,!0)}}computeConnections(){for(const e of this.gridLines.values()){const{type:t,row:i,col:r}=e;"horizontal"===t?(r>=0&&i>0&&(e.connections[a.NW]=this.generateGridLineId("v",i-1,r)),i>0&&(e.connections[a.NE]=this.generateGridLineId("v",i-1,r+1)),r>=0&&i<this.rows&&(e.connections[a.SW]=this.generateGridLineId("v",i,r)),i<this.rows&&(e.connections[a.SE]=this.generateGridLineId("v",i,r+1))):(i>=0&&r>0&&(e.connections[a.NW]=this.generateGridLineId("h",i,r-1)),i>=0&&r<this.cols&&(e.connections[a.NE]=this.generateGridLineId("h",i,r)),i<this.rows&&r>0&&(e.connections[a.SW]=this.generateGridLineId("h",i+1,r-1)),i<this.rows&&r<this.cols&&(e.connections[a.SE]=this.generateGridLineId("h",i+1,r)))}}initializeUsedDirections(){for(const[e,t]of this.gridLines.entries())this.usedDirections.set(e,new Set);for(const[e,t]of this.gridLines.entries())this.isBoundaryGridLine(t)&&("horizontal"===t.type?0===t.row?(this.usedDirections.get(e).add(a.NW),this.usedDirections.get(e).add(a.NE)):t.row===this.rows&&(this.usedDirections.get(e).add(a.SW),this.usedDirections.get(e).add(a.SE)):0===t.col?(this.usedDirections.get(e).add(a.SW),this.usedDirections.get(e).add(a.NW)):t.col===this.cols&&(this.usedDirections.get(e).add(a.NE),this.usedDirections.get(e).add(a.SE)))}isBoundaryGridLine(e){if(!e)return!1;const{type:t,row:i,col:r}=e;return"horizontal"===t?0===i||i===this.rows:0===r||r===this.cols}getGridLine(e){return this.gridLines.get(e)||null}getAdjacentGridLine(e,t){const i=this.getGridLine(e);if(!i)return null;if(![a.NW,a.NE,a.SW,a.SE].includes(t))return null;const r=i.connections[t];if(null===r)throw new Error("Curve left the grid");return r}setMirror(e,t){const i=this.getGridLine(e);i&&(i.isMirror=t)}getReflectedDirection(e,t){const i=this.getGridLine(e);if(!i)return t;if(!i.isMirror)return t;if("horizontal"===i.type)switch(t){case a.NW:return a.SW;case a.NE:return a.SE;case a.SW:return a.NW;case a.SE:return a.NE;default:return t}else switch(t){case a.NW:return a.NE;case a.NE:return a.NW;case a.SW:return a.SE;case a.SE:return a.SW;default:return t}}markDirectionUsed(e,t){this.usedDirections.has(e)&&this.usedDirections.get(e).add(t)}isDirectionUsed(e,t){return!!this.usedDirections.has(e)&&this.usedDirections.get(e).has(t)}getUnusedDirections(e){const t=[a.NW,a.NE,a.SW,a.SE];if(!this.getGridLine(e)||!this.usedDirections.has(e))return[];const i=this.usedDirections.get(e);return t.filter((e=>!i.has(e)))}resetUsedDirections(){this.initializeUsedDirections()}isEdgeDirection(e,t){const i=this.getGridLine(e);return!i||(![a.NW,a.NE,a.SW,a.SE].includes(t)||null===i.connections[t])}getMirrorCount(){let e=0;for(const t of this.gridLines.values())t.isMirror&&e++;return e}randomizeMirrors(e){if(e<0||e>1)throw new Error("Probability must be between 0 and 1");console.log("Put Mirror with probability",e);for(const[t,i]of this.gridLines.entries()){const{type:i,row:r,col:n}=this.parseGridLineId(t);"h"===i&&(0===r||r===this.rows)||"v"===i&&(0===n||n===this.cols)||(Math.random()<e?this.setMirror(t,!0):this.setMirror(t,!1))}}generateGridLineId(e,t,i){return"".concat(e,"_").concat(t,"_").concat(i)}parseGridLineId(e){const t=e.split("_");return{type:t[0],row:parseInt(t[1],10),col:parseInt(t[2],10)}}}a.NW=0,a.NE=1,a.SW=2,a.SE=3;class h{constructor(e,t){this.gridLines=[e],this.directions=[t],this.isClosed=!1,this.leftGrid=!1,this.exitPoint=null,this.exitDirection=null}addSegment(e,t){this.gridLines.push(e),this.directions.push(t)}buildCurve(e){let t=this.gridLines[0],i=this.directions[0];for(e.markDirectionUsed(t.id,i);this.gridLines.length<1e6;)try{const r=e.getAdjacentGridLine(t.id,i),n=e.getGridLine(r);if(!n)return console.warn("Invalid grid line returned: ".concat(r)),!1;let s=i;n.isMirror&&(s=e.getReflectedDirection(r,i)),this.addSegment(n,s),e.markDirectionUsed(r,s);const o=i===a.NW?a.SE:i===a.SE?a.NW:i===a.NE?a.SW:a.NE;if(e.markDirectionUsed(r,o),this.gridLines.length>2&&n.id===this.gridLines[0].id&&s===this.directions[0])return this.isClosed=!0,!0;t=n,i=s}catch(r){if("Curve left the grid"===r.message)return this.leftGrid=!0,this.exitPoint=t,this.exitDirection=i,!0;throw r}return console.warn("Maximum segments reached without forming a loop"),!1}toString(){const e=["NW","NE","SW","SE"];let t="MirrorCurve:\n";for(let i=0;i<this.gridLines.length;i++){const r=this.gridLines[i],n=e[this.directions[i]];t+="  ".concat(r.id," -> ").concat(n,"\n")}return this.isClosed?t+="  (Closed loop)":this.leftGrid?t+="  (Left grid at ".concat(this.exitPoint.id," in direction ").concat(e[this.exitDirection],")"):t+="  (Open path)",t}}function c(e){console.log("Looking for the next available curve...");for(const[i,r]of e.gridLines.entries()){const n=e.getUnusedDirections(i);if(n.length>0){const s=n[0];console.log("Starting curve from ".concat(i," in direction ").concat(s));const o=new h(r,s);try{if(o.buildCurve(e))return console.log("Built curve with ".concat(o.gridLines.length," segments (").concat(o.isClosed?"closed loop":"open path",")")),o}catch(t){console.error("Error building curve from ".concat(i," in direction ").concat(s,":"),t)}}}return console.log("No more curves available"),null}class l{constructor(e){this.konva=e,this.styleSettings={lineStyles:{grid:{width:1},gridPoint:{radius:2},mirror:{width:2},centerDot:{radius:3}}}}renderGrid(e,t,i){const{cellSize:r=1,showGridLines:n=!0,showGridPoints:s=!0,showMirrors:o=!0,showCenterDots:a=!1,gridLineColor:h="#cccccc",mirrorColor:c="#333333"}=i;if(t.destroyChildren(),n)for(const l of e.gridLines.values()){const e=l.col*r,i=l.row*r,n="horizontal"===l.type?(l.col+1)*r:e,s="vertical"===l.type?(l.row+1)*r:i,o=new this.konva.Line({points:[e,i,n,s],stroke:h,strokeWidth:this.styleSettings.lineStyles.grid.width});t.add(o)}if(s)for(let l=0;l<=e.rows;l++)for(let i=0;i<=e.cols;i++){const e=new this.konva.Circle({x:i*r,y:l*r,radius:this.styleSettings.lineStyles.gridPoint.radius,fill:h});t.add(e)}if(o)for(const l of e.gridLines.values()){if(!l.isMirror)continue;const e=l.col*r,i=l.row*r,n="horizontal"===l.type?(l.col+1)*r:e,s="vertical"===l.type?(l.row+1)*r:i,o=new this.konva.Line({points:[e,i,n,s],stroke:c,strokeWidth:this.styleSettings.lineStyles.mirror.width});t.add(o)}if(a)for(let l=0;l<e.rows;l++)for(let i=0;i<e.cols;i++){const e=new this.konva.Circle({x:(i+.5)*r,y:(l+.5)*r,radius:this.styleSettings.lineStyles.centerDot.radius,fill:c});t.add(e)}}}function d(e,t,i,r,n){const s=[];for(let o=0;o<n;o++){const a=o/n,h=a*a,c=h*a,l=2*c-3*h+1,d=c-2*h+a,u=-2*c+3*h,g=c-h,m=l*e.x+d*i.x+u*t.x+g*r.x,v=l*e.y+d*i.y+u*t.y+g*r.y;s.push({x:m,y:v})}return s}function u(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.5,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:10;const r=e.length;if(r<2)return e.slice();const n=r>1&&Math.abs(e[0].x-e[r-1].x)<.001&&Math.abs(e[0].y-e[r-1].y)<.001,s=n?e.slice(0,r-1):e,o=s.length,a=[];for(let c=0;c<o;c++){const e=s[(c-1+o)%o],i=s[(c+1)%o];a.push({x:(i.x-e.x)*(1-t)/2,y:(i.y-e.y)*(1-t)/2})}const h=[];for(let c=0;c<o;c++){const e=d(s[c],s[(c+1)%o],a[c],a[(c+1)%o],i);h.push(...e)}return n&&h.push({x:s[0].x,y:s[0].y}),h}function g(e,t,i){let r,n;if("horizontal"===e.type?(r=(e.col+.5)*i,n=e.row*i):(r=e.col*i,n=(e.row+.5)*i),e.isMirror){const s=i/6;"vertical"===e.type?1===t||3===t?r+=s:0!==t&&2!==t||(r-=s):0===t||1===t?n-=s:2!==t&&3!==t||(n+=s)}return{x:r,y:n}}function m(e,t){const i=e*t;return i<=25?12:i<=100?10:i<=400?Math.max(3,6):Math.max(2,4)}class v{constructor(e){this.konva=e,this.styleSettings={lineStyles:{curve:{width:3},helperPoint:{radius:4}}},this.animationCache=new Map}renderCurves(e,t,i){t.destroyChildren();const{cellSize:r=1,colorScheme:n=["#3498db"],curveStyle:s="curved",tension:o=0,smooth:a=!0,showHelperPoints:h=!1,helperPointColor:c="#ff0000",animationPath:l=null,helperPoints:d=[],gridRows:u=5,gridCols:g=5}=i;if(e.forEach(((e,i)=>{const h=this.createKonvaCurve(e,i,r,n,{curveStyle:s,tension:o,smooth:a,gridRows:u,gridCols:g});h&&t.add(h)})),l){const i=this.createKonvaCurve(l,e.length,r,n,{curveStyle:s,tension:o,smooth:a,gridRows:u,gridCols:g});i&&t.add(i)}if(h){const e=this.styleSettings.lineStyles.helperPoint.radius;d.forEach((i=>{i.forEach((i=>{const r=new this.konva.Circle({x:i.x,y:i.y,radius:e,fill:c});t.add(r)}))}))}}createKonvaCurve(e,t,i,r,n){if(!e)return null;const{curveStyle:s="curved",tension:o=0,smooth:a=!0,gridRows:h=5,gridCols:c=5}=n;let l=[],d=!1;if("animationPath"===e.type)l=e.points||[],d=e.isClosed||!1;else if(e.gridLines&&Array.isArray(e.gridLines))if(d=e.isClosed||!1,"curved"===s){l=u(e.gridLines.map(((t,r)=>g(t,e.directions[r],i))),o,m(h,c,!1))}else l=e.gridLines.map((e=>"horizontal"===e.type?{x:(e.col+.5)*i,y:e.row*i}:{x:e.col*i,y:(e.row+.5)*i}));if(0===l.length)return null;const v=[];l.forEach((e=>{v.push(e.x,e.y)}));const p=this.styleSettings.lineStyles.curve.width,f=r[t%r.length];return new this.konva.Line({points:v,stroke:f,strokeWidth:p,lineCap:"round",lineJoin:"round",closed:d})}createAnimationPathByDistance(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(!e||!e.gridLines||0===e.gridLines.length)return null;const{tension:n=.5,curveStyle:s="curved",smooth:o=!0,gridRows:a=5,gridCols:h=5}=r,c="".concat(e.gridLines[0].id,"-").concat(n,"-").concat(s);let l=null,d=0,v=[];if(this.animationCache.has(c)){const e=this.animationCache.get(c);l=e.points,d=e.totalLength,v=e.segmentLengths}else{const i=m(a,h,!0);l=u(e.gridLines.map(((i,r)=>g(i,e.directions[r],t))),n,i),d=0,v=[];for(let e=1;e<l.length;e++){const t=l[e].x-l[e-1].x,i=l[e].y-l[e-1].y,r=Math.sqrt(t*t+i*i);v.push(r),d+=r}this.animationCache.set(c,{points:l,totalLength:d,segmentLengths:v})}if(l.length<2)return{completed:!0};if(d<.001)return{completed:!0};const p=Math.min(i,d);let f=0,y=0;for(;y<v.length&&f+v[y]<p;)f+=v[y],y++;const C=l.slice(0,y+1);if(y<v.length){const e=(p-f)/v[y],t=l[y],i=l[y+1],r={x:t.x+(i.x-t.x)*e,y:t.y+(i.y-t.y)*e};C.push(r)}return p>=d?{completed:!0}:{type:"animationPath",points:C,isClosed:!1,completed:!1,totalLength:d}}clearCache(){this.animationCache.clear()}clearCurveFromCache(e){for(const t of this.animationCache.keys())t.startsWith(e)&&this.animationCache.delete(t)}}class p extends o{constructor(e){super(e),this.grid=null,this.curves=[],this.animationPath=null,this.gridLayout={},this.helperPoints=[],this.isAnimating=!1,this.distanceTraveled=0,this.animationCurve=null,this.animationQueue=[],this.gridRenderer=null,this.curveRenderer=null,this.gridGroup=null,this.staticCurveGroup=null,this.animationGroup=null,this.isDirtyGrid=!0,this.isDirtyStaticCurves=!0,this.isDirtyAnimation=!0,this.lastWidth=0,this.lastHeight=0}async start(){this.addSlider("rows","Grid Rows",5,{min:2,max:60,step:1}),this.addSlider("cols","Grid Columns",5,{min:2,max:60,step:1}),this.addCheckbox("showGridLines","Show Grid Lines",!0),this.addCheckbox("showGridPoints","Show Grid Points",!0),this.addCheckbox("showMirrors","Show Mirrors",!0),this.addCheckbox("showCenterDots","Show Center Dots",!1),this.addColorPalette(),this.addSlider("mirrorProbability","Mirror Probability",.5,{min:.1,max:1,step:.1},"structural"),this.addCheckbox("animateCurves","Animate Curves",!0,"structural"),this.addSlider("animationSpeed","Animation Speed",15,{min:1,max:50,step:1},"structural"),this.addCheckbox("smooth","Smooth Curves",!0,"advanced"),this.addSlider("tension","Curve Smoothness",.01,{min:0,max:1,step:.1},"advanced"),this.addDropdown("curveStyle","Curve Style","curved",["curved","jagged"],"advanced"),this.addCheckbox("showHelperPoints","Show Helper Points",!1,"advanced"),this.addAction("randomize","Randomize Mirrors",(()=>this.randomizeMirrors())),this.addAction("findAllCurves","Find All Curves",(()=>this.discoverAllCurves())),this.addAction("clearCurves","Clear Curves",(()=>this.clearCurves())),this.addAction("animateCurve","Animate Next Curve",(()=>this.animateNextCurve())),this.initializeGrid(),this.gridRenderer=new l(this.renderEnv.konva),this.curveRenderer=new v(this.renderEnv.konva),this.setupKonvaObjects(),this.animationHandler=this.requestAnimation(this.animate.bind(this))}initializeGrid(){const e=this.getParameter("rows"),t=this.getParameter("cols");this.grid=new a(e,t);const i=this.getParameter("mirrorProbability");this.grid.randomizeMirrors(i),this.curves=[],this.animationPath=null,this.helperPoints=[],this.animationQueue=[],this.isAnimating=!1,this.animationCurve=null,this.distanceTraveled=0,this.curveRenderer&&this.curveRenderer.clearCache(),this.isDirtyGrid=!0,this.isDirtyStaticCurves=!0,this.isDirtyAnimation=!0}randomizeMirrors(){if(!this.grid)return;const e=this.getParameter("mirrorProbability");this.grid.randomizeMirrors(e),this.clearCurves(),this.isDirtyGrid=!0,this.updateStaticCurves()}discoverAllCurves(){if(!this.grid)return;const e=[];let t;for(;null!==(t=c(this.grid));)e.push(t);0!==e.length?(console.log("Found ".concat(e.length," new curves")),this.getParameter("animateCurves")?(this.animationQueue=[...this.animationQueue,...e],this.isAnimating||this.startNextAnimation()):(e.forEach((e=>{e.isCompleted=!0})),this.curves=[...this.curves,...e],this.updateHelperPoints(),this.isDirtyStaticCurves=!0)):console.log("No new curves found")}clearCurves(){this.curves=[],this.animationPath=null,this.helperPoints=[],this.isAnimating=!1,this.animationCurve=null,this.animationQueue=[],this.distanceTraveled=0,this.curveRenderer&&this.curveRenderer.clearCache(),this.grid&&this.grid.resetUsedDirections(),this.isDirtyStaticCurves=!0,this.isDirtyAnimation=!0}updateHelperPoints(){this.helperPoints=function(e,t){const i=[];return e.forEach((e=>{if(e.isCompleted&&e.gridLines&&Array.isArray(e.gridLines)){const r=e.gridLines.map(((r,s)=>{const o=g(r,e.directions[s],t);return(0,n.A)((0,n.A)({},o),{},{curveIndex:i.length})}));i.push(r)}})),i}(this.curves,this.gridLayout.cellSize),this.isDirtyStaticCurves=!0}startNextAnimation(){if(0===this.animationQueue.length)return this.isAnimating=!1,this.animationPath=null,void(this.isDirtyAnimation=!0);if(this.animationCurve=this.animationQueue.shift(),this.distanceTraveled=0,this.isAnimating=!0,this.isDirtyAnimation=!0,this.curveRenderer&&this.animationCurve&&this.animationCurve.gridLines[0]){const e=this.animationCurve.gridLines[0].id;e&&this.curveRenderer.clearCurveFromCache(e)}}animate(e){const t=this.renderEnv.stage,i=t.width(),r=t.height();if(i===this.lastWidth&&r===this.lastHeight||this.updateLayout(),this.isAnimating&&this.animationCurve){const t=e*this.getParameter("animationSpeed")*100;this.distanceTraveled+=t,this.animationPath=this.curveRenderer.createAnimationPathByDistance(this.animationCurve,this.gridLayout.cellSize,this.distanceTraveled,{tension:this.getParameter("tension"),curveStyle:this.getParameter("curveStyle"),gridRows:this.getParameter("rows"),gridCols:this.getParameter("cols")}),this.isDirtyAnimation=!0,this.animationPath&&this.animationPath.completed&&(this.animationCurve.isCompleted=!0,this.curves.push(this.animationCurve),this.updateHelperPoints(),this.isDirtyStaticCurves=!0,this.startNextAnimation())}return this.isDirtyAnimation&&(this.updateAnimation(),this.isDirtyAnimation=!1),this.isDirtyStaticCurves&&(this.updateStaticCurves(),this.isDirtyStaticCurves=!1),this.isDirtyGrid&&(this.updateGrid(),this.isDirtyGrid=!1),!0}setupKonvaObjects(){this.gridGroup=this.createGroup("grid"),this.staticCurveGroup=this.createGroup("main"),this.animationGroup=this.createGroup("animation"),this.isDirtyGrid=!0,this.isDirtyStaticCurves=!0,this.isDirtyAnimation=!0,this.updateLayout()}updateLayout(){const e=this.renderEnv.stage,t=e.width(),i=e.height();this.gridLayout=function(e,t,i,r){const n=.05*Math.min(e,t),s=e-2*n,o=t-2*n,a=Math.min(s/r,o/i);return{cellSize:a,offsetX:n+(s-a*r)/2,offsetY:n+(o-a*i)/2,padding:n,drawableWidth:s,drawableHeight:o,gridRows:i,gridCols:r}}(t,i,this.grid.rows,this.grid.cols);const{offsetX:r,offsetY:n}=this.gridLayout;this.gridGroup.position({x:r,y:n}),this.staticCurveGroup.position({x:r,y:n}),this.animationGroup.position({x:r,y:n}),this.clearCurves(),this.lastWidth=t,this.lastHeight=i,this.isDirtyGrid=!0,this.isDirtyStaticCurves=!0,this.isDirtyAnimation=!0,this.updateGrid(),this.updateStaticCurves(),this.updateAnimation()}updateGrid(){const e=this.core.colorSchemeManager.getTextColor(),t=this.core.colorSchemeManager.getStructuralColor("strong");this.gridGroup.destroyChildren(),this.gridRenderer.renderGrid(this.grid,this.gridGroup,{cellSize:this.gridLayout.cellSize,showGridLines:this.getParameter("showGridLines"),showGridPoints:this.getParameter("showGridPoints"),showMirrors:this.getParameter("showMirrors"),showCenterDots:this.getParameter("showCenterDots"),gridLineColor:e+"44",mirrorColor:t}),this.redrawLayer("grid")}updateStaticCurves(){const e=this.getParameter("colorPalette"),t=this.core.colorSchemeManager.getPalette(e),i=this.core.colorSchemeManager.getAccentColor();this.staticCurveGroup.destroyChildren(),this.curveRenderer.renderCurves(this.curves,this.staticCurveGroup,{cellSize:this.gridLayout.cellSize,colorScheme:t,curveStyle:this.getParameter("curveStyle"),tension:this.getParameter("tension"),smooth:this.getParameter("smooth"),showHelperPoints:this.getParameter("showHelperPoints"),helperPointColor:i,helperPoints:this.helperPoints,gridRows:this.getParameter("rows"),gridCols:this.getParameter("cols")}),this.redrawLayer("main")}updateAnimation(){const e=this.getParameter("colorPalette"),t=this.core.colorSchemeManager.getPalette(e);if(this.animationGroup.destroyChildren(),this.animationPath){let e=t[this.curves.length%t.length];this.curveRenderer.renderCurves([],this.animationGroup,{cellSize:this.gridLayout.cellSize,colorScheme:[e],curveStyle:this.getParameter("curveStyle"),tension:this.getParameter("tension"),smooth:this.getParameter("smooth"),animationPath:this.animationPath,gridRows:this.getParameter("rows"),gridCols:this.getParameter("cols")})}this.redrawLayer("animation")}animateNextCurve(){if(!this.grid)return void console.warn("Grid not initialized");const e=c(this.grid);e?(console.log("Found next curve, queueing for animation"),this.animationQueue.push(e),this.isAnimating||this.startNextAnimation()):console.log("No more curves available")}onParameterChanged(e,t){if("rows"===e||"cols"===e)return this.initializeGrid(),void this.updateLayout();"showGridLines"!==e&&"showGridPoints"!==e&&"showMirrors"!==e&&"showCenterDots"!==e||(this.isDirtyGrid=!0),"colorPalette"!==e&&"showHelperPoints"!==e&&"tension"!==e&&"curveStyle"!==e&&"smooth"!==e||(this.isDirtyStaticCurves=!0,this.isDirtyAnimation=!0)}handleInteraction(e,t){if("click"===e&&this.grid){const e=function(e,t,i){if(!e||!t||!i)return null;const{cellSize:r,offsetX:n,offsetY:s}=i,o=(t.x-n)/r,a=(t.y-s)/r;if(o>=0&&o<=e.cols&&a>=0&&a<=e.rows){let t=null,i=1/0;for(const n of e.gridLines.values()){if(e.isBoundaryGridLine(n))continue;let s;if("horizontal"===n.type){const e=n.col*r,t=(n.col+1)*r;if(!(o>=e/r&&o<=t/r))continue;s=Math.abs(a-n.row)}else{const e=n.row*r,t=(n.row+1)*r;if(!(a>=e/r&&a<=t/r))continue;s=Math.abs(o-n.col)}s<i&&(i=s,t=n)}if(t&&i<.2)return t}return null}(this.grid,t,this.gridLayout);e&&(this.grid.setMirror(e.id,!e.isMirror),this.clearCurves(),this.isDirtyGrid=!0)}}async unload(){this.animationHandler&&this.cancelAnimation(this.animationHandler),this.grid=null,this.curves=[],this.animationPath=null,this.gridLayout={},this.helperPoints=[],this.isAnimating=!1,this.distanceTraveled=0,this.animationCurve=null,this.animationQueue=[],this.gridRenderer=null,this.curveRenderer=null,await super.unload()}}p.id="mirror-curves",(0,r.A)(p,"name","Mirror Curves"),p.description="Visualization of mirror curves based on grid reflections",p.renderingType="2d"},2834:(e,t,i)=>{i.d(t,{j:()=>r});class r{constructor(e){const t=this.constructor;if(!t.id||!t.name||!t.renderingType)throw new Error("Plugin class must have static id, name, and renderingType properties");this.id=t.id,this.name=t.name,this.description=t.description||"No description provided",this.renderingType=t.renderingType,this.core=e,this.isLoaded=!1,this._eventHandlers=[],this._animationHandlers=[],this._visualParameters=[],this._structuralParameters=[],this._advancedParameters=[]}async load(){if(this.isLoaded)return!0;try{return console.log("Loading plugin: ".concat(this.name," (").concat(this.id,")")),this.renderEnv=this.core.getRenderingEnvironment(),await this.start(),this.isLoaded=!0,!0}catch(e){return console.error("Error loading plugin ".concat(this.id,":"),e),await this.unload(),!1}}async start(){}async unload(){if(!this.isLoaded)return!0;try{return console.log("Unloading plugin: ".concat(this.name," (").concat(this.id,")")),this._cancelAllAnimations(),this._removeAllEventHandlers(),this.isLoaded=!1,this.renderEnv=null,this._visualParameters=[],this._structuralParameters=[],this._advancedParameters=[],!0}catch(e){return console.error("Error unloading plugin ".concat(this.id,":"),e),!1}}addSlider(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"visual";const s={id:e,type:"slider",label:t,default:i,min:void 0!==r.min?r.min:0,max:void 0!==r.max?r.max:100,step:void 0!==r.step?r.step:1};return this._addParameter(s,n),this}addCheckbox(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"visual";const n={id:e,type:"checkbox",label:t,default:i};return this._addParameter(n,r),this}addColor(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"visual";const n={id:e,type:"color",label:t,default:i};return this._addParameter(n,r),this}addColorPalette(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"colorPalette",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"Color Palette",i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"visual";const r=this.getPaletteInfo(),n=this.getCurrentPaletteName(),s=r.map((e=>({value:e.id,label:e.name})));return this.addDropdown(e,t,n,s,i),this}addDropdown(e,t,i,r){let n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"visual";const s={id:e,type:"dropdown",label:t,default:i,options:r};return this._addParameter(s,n),this}addNumber(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"visual";const s={id:e,type:"number",label:t,default:i};return void 0!==r.min&&(s.min=r.min),void 0!==r.max&&(s.max=r.max),void 0!==r.step&&(s.step=r.step),this._addParameter(s,n),this}addText(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"visual";const n={id:e,type:"text",label:t,default:i};return this._addParameter(n,r),this}_addParameter(e,t){switch(t){case"visual":this._visualParameters.push(e);break;case"structural":this._structuralParameters.push(e);break;case"advanced":this._advancedParameters.push(e);break;default:console.warn("Unknown parameter group: ".concat(t,", defaulting to visual")),this._visualParameters.push(e),t="visual"}const i=t.charAt(0).toUpperCase()+t.slice(1),r="addParameters".concat(i);this.core&&"function"===typeof this.core[r]?this.core[r]([e]):console.warn("Cannot add parameter ".concat(e.id," - no method available for group ").concat(t))}removeParameter(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(!this.core||"function"!==typeof this.core.removeParameter)return console.warn("Core removeParameter method not available"),!1;const i=this.core.removeParameter(e,t);if(i){const i=t=>{const i=t.findIndex((t=>t.id===e));return-1!==i&&(t.splice(i,1),!0)};if(t)switch(t){case"visual":i(this._visualParameters);break;case"structural":i(this._structuralParameters);break;case"advanced":i(this._advancedParameters)}else i(this._visualParameters)||i(this._structuralParameters)||i(this._advancedParameters)}return i}emptyParameters(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(e)switch(e){case"visual":this._visualParameters=[];break;case"structural":this._structuralParameters=[];break;case"advanced":this._advancedParameters=[];break;default:return console.warn("Unknown parameter group: ".concat(e)),!1}else this._visualParameters=[],this._structuralParameters=[],this._advancedParameters=[];return this.core&&"function"===typeof this.core.emptyParameters?this.core.emptyParameters(e):(console.warn("Core emptyParameters method not available"),!1)}setParameter(e,t){return!(!this.core||"function"!==typeof this.core.changeParameter)&&this.core.changeParameter(e,t)}getParameter(e){if(this.core&&"function"===typeof this.core.getAllParameters){return this.core.getAllParameters()[e]}}getAllParameters(){return this.core&&"function"===typeof this.core.getAllParameters?this.core.getAllParameters():{}}addAction(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return!(!this.core||"function"!==typeof this.core.addAction)&&this.core.addAction(e,t,i,r)}removeAction(e){return!(!this.core||"function"!==typeof this.core.removeAction)&&this.core.removeAction(e)}refresh(){}requestAnimation(e){if(!this.core||!this.core.animationManager||"function"!==typeof this.core.animationManager.requestAnimation)return console.warn("Animation manager not available"),null;const t=this.core.animationManager.requestAnimation(e);return t&&this._animationHandlers.push(t),t}cancelAnimation(e){if(!this.core||!this.core.animationManager||"function"!==typeof this.core.animationManager.cancelAnimation)return!1;this.core.animationManager.cancelAnimation(e);const t=this._animationHandlers.indexOf(e);return-1!==t&&(this._animationHandlers.splice(t,1),!0)}_cancelAllAnimations(){this.core&&this.core.animationManager&&"function"===typeof this.core.animationManager.cancelAnimation&&(this._animationHandlers.forEach((e=>{this.core.animationManager.cancelAnimation(e)})),this._animationHandlers=[])}onParameterChanged(e,t,i){}handleInteraction(e,t){}_removeAllEventHandlers(){this._eventHandlers.forEach((e=>{var t;if(e.target&&e.type&&e.callback)"function"===typeof e.target.off&&e.target.off(e.type,e.callback);else if("parameterChanged"===e.type){var i;null===(i=this.core)||void 0===i||i.removeParameterCallback(e.callback)}else if("action"===e.type){var r;null===(r=this.core)||void 0===r||r.removeActionCallback(e.callback)}else"paletteChanged"===e.type&&null!==(t=this.core)&&void 0!==t&&t.events&&this.core.events.off("paletteChanged",e.callback)})),this._eventHandlers=[]}_handleParameterChanged(e,t,i){try{"function"===typeof this.onParameterChanged&&this.onParameterChanged(e,t,i),this.refresh()}catch(r){console.error("Error handling parameter change in plugin ".concat(this.id,":"),r)}}_handleActionExecution(e){try{const n=this.core._actions.get(e);if(n&&"function"===typeof n.callback){for(var t=arguments.length,i=new Array(t>1?t-1:0),r=1;r<t;r++)i[r-1]=arguments[r];const e=n.callback(...i);return this.refresh(),e}}catch(n){console.error("Error executing action ".concat(e," in plugin ").concat(this.id,":"),n),this.core&&this.core.uiManager&&this.core.uiManager.showError("Action failed: ".concat(n.message))}return!1}getStructuralColor(e){return this.core&&this.core.colorSchemeManager?this.core.colorSchemeManager.getStructuralColor(e):"#000000"}getMainColor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.core&&this.core.colorSchemeManager?this.core.colorSchemeManager.getMainColor(e):"#000000"}getMainColors(){return this.core&&this.core.colorSchemeManager?this.core.colorSchemeManager.getMainColors():[]}getFunctionalColor(e){return this.core&&this.core.colorSchemeManager?this.core.colorSchemeManager.getFunctionalColor(e):"#000000"}onPaletteChanged(e){this.core&&this.core.events&&(this.core.events.on("paletteChanged",e),this._eventHandlers.push({type:"paletteChanged",callback:e}))}getPaletteInfo(){return this.core&&this.core.colorSchemeManager?this.core.colorSchemeManager.getPaletteInfo():[]}getCurrentPaletteName(){return this.core&&this.core.colorSchemeManager?this.core.colorSchemeManager.getCurrentPaletteName():"default"}setCurrentPalette(e){return!(!this.core||!this.core.colorSchemeManager)&&this.core.colorSchemeManager.setCurrentPalette(e)}}}}]);
//# sourceMappingURL=601.67eef2b5.chunk.js.map