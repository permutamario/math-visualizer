"use strict";(self.webpackChunkmath_visualizer_react=self.webpackChunkmath_visualizer_react||[]).push([[284],{6284:(t,e,r)=>{r.r(e),r.d(e,{default:()=>s});var a=r(8239);class s extends a.A{constructor(t){super(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:"Permutahedron"),this.types=[{value:"A3",label:"Type A\u2083"},{value:"B3/C3",label:"Type B\u2083/C\u2083"}],this.currentType="A3"}addFamilyParameters(){this.plugin.addDropdown("permutahedronType","Coxeter Type","A3",this.types,"structural")}calculateVertices(){let t;if(this.currentType=this.plugin.getParameter("permutahedronType")||"A3","B3/C3"===this.currentType)t=this.buildTypeBC();else t=this.buildTypeA();const e=this.plugin.getParameter("size")||1;return t.map((t=>t.map((t=>t*e))))}buildTypeA(){const t=this.permutations([1,2,3,4]),e=this.orthonormalBasis([[1,-1,0,0],[0,1,-1,0],[0,0,1,-1]]);return t.map((t=>e.map((e=>this.dot(t,e)))))}buildTypeBC(){const t=this.signedPermutations([1,2,3]),e=t.reduce(((t,e)=>e.map(((e,r)=>t[r]+e))),[0,0,0]).map((e=>e/t.length));return t.map((t=>t.map(((t,r)=>t-e[r]))))}dot(t,e){return t.reduce(((t,r,a)=>t+r*e[a]),0)}sub(t,e){return t.map(((t,r)=>t-e[r]))}scale(t,e){return t.map((t=>t*e))}norm(t){return Math.hypot(...t)}orthonormalBasis(t){const e=[];for(let r of t){let t=[...r];for(let r of e)t=this.sub(t,this.scale(r,this.dot(t,r)));const a=this.norm(t);a>1e-8&&e.push(this.scale(t,1/a))}return e}permutations(t){return t.length<=1?[t]:t.flatMap(((e,r)=>this.permutations(t.slice(0,r).concat(t.slice(r+1))).map((t=>[e,...t]))))}signedPermutations(t){const e=t.map((()=>[-1,1])).reduce(((t,e)=>t.flatMap((t=>e.map((e=>[...t,e]))))),[[]]);return this.permutations(t).flatMap((t=>e.map((e=>t.map(((t,r)=>t*e[r]))))))}}}}]);
//# sourceMappingURL=284.7975fffa.chunk.js.map