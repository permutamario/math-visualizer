{"version":3,"file":"static/js/601.67eef2b5.chunk.js","mappings":"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","sources":["lib/core/Plugin2D.js","lib/plugins/mirror-curve/grid.js","lib/plugins/mirror-curve/mirrorCurve.js","lib/plugins/mirror-curve/curveStartFinder.js","lib/plugins/mirror-curve/gridRenderer.js","lib/plugins/mirror-curve/spline.js","lib/plugins/mirror-curve/helperPointCalculator.js","lib/plugins/mirror-curve/curveRenderer.js","lib/plugins/mirror-curve/index.js","lib/plugins/mirror-curve/layoutManager.js","lib/plugins/mirror-curve/interactionHandler.js","lib/core/BasePlugin.js"],"sourcesContent":["// src/core/Plugin2D.js\nimport { BasePlugin } from './BasePlugin.js';\n\n/**\n * Specialized plugin class for 2D visualizations using Konva\n * Provides enhanced APIs for managing Konva objects\n */\nexport class Plugin2D extends BasePlugin {\n  /**\n   * Create a new 2D plugin instance\n   * @param {AppCore} core - Reference to the application core\n   */\n  constructor(core) {\n    super(core);\n    \n    // Ensure this is a 2D plugin\n    if (this.renderingType !== '2d') {\n      console.warn(`Plugin ${this.id} should have renderingType='2d'`);\n      this.renderingType = '2d';\n    }\n    \n    // Resource tracking for cleanup\n    this._shapes = new Map();   // Map of shape ID to shape object\n    this._groups = new Map();   // Map of group ID to group object\n    this._eventBindings = [];   // List of event bindings\n    \n    // Layer quick access cache\n    this._layers = {\n      background: null,\n      grid: null,\n      main: null,\n      overlay: null,\n      animation: null\n    };\n    \n    // Unique ID generator for shapes\n    this._nextShapeId = 1;\n  }\n  \n  /**\n   * Get a layer by name\n   * @param {string} name - Layer name ('background', 'grid', 'main', 'overlay', 'animation')\n   * @returns {Object} Konva layer\n   */\n  getLayer(name) {\n    // Check if we already have this layer cached\n    if (this._layers[name]) return this._layers[name];\n    \n    // Check if the layer exists in the rendering environment\n    if (!this.renderEnv || !this.renderEnv.stage) {\n      console.error('Rendering environment not initialized');\n      return null;\n    }\n    \n    // Try to find the layer by name in the stage\n    const layers = this.renderEnv.stage.getLayers();\n    const existingLayer = layers.find(layer => layer.name() === name);\n    \n    if (existingLayer) {\n      // Cache the layer for future use\n      this._layers[name] = existingLayer;\n      return existingLayer;\n    }\n    \n    // Layer doesn't exist, create it\n    const konva = this.renderEnv.konva;\n    if (!konva) {\n      console.error('Konva not available in rendering environment');\n      return null;\n    }\n    \n    // Create new layer\n    const newLayer = new konva.Layer({ name });\n    \n    // Add to stage at the appropriate position\n    const insertionOrder = ['background', 'grid', 'main', 'overlay', 'animation'];\n    const insertionIndex = insertionOrder.indexOf(name);\n    \n    if (insertionIndex === -1) {\n      // Not a standard layer, add at the top\n      this.renderEnv.stage.add(newLayer);\n    } else {\n      // Insert at the correct position based on the standard order\n      const existingLayers = this.renderEnv.stage.getLayers();\n      \n      // Try to insert in proper z-order\n      let inserted = false;\n      for (let i = insertionIndex + 1; i < insertionOrder.length; i++) {\n        const higherLayerName = insertionOrder[i];\n        const higherLayer = existingLayers.find(l => l.name() === higherLayerName);\n        \n        if (higherLayer) {\n          // Insert before this higher layer\n          newLayer.moveToTop();\n          higherLayer.moveToTop();\n          inserted = true;\n          break;\n        }\n      }\n      \n      if (!inserted) {\n        // No higher layers found, add to the top\n        this.renderEnv.stage.add(newLayer);\n      }\n    }\n    \n    // Cache the layer\n    this._layers[name] = newLayer;\n    return newLayer;\n  }\n  \n  /**\n   * Create a unique ID for tracking shapes\n   * @returns {string} Unique shape ID\n   * @private\n   */\n  _createUniqueId() {\n    return `shape_${this.id}_${this._nextShapeId++}`;\n  }\n  \n  /**\n   * Register a shape or group for tracking\n   * @param {Object} shape - Konva shape or group\n   * @param {string} layerName - Layer name\n   * @returns {Object} The registered shape\n   * @private\n   */\n  _registerShape(shape, layerName) {\n    // Generate a unique ID if the shape doesn't have one\n    if (!shape.id() || shape.id() === '') {\n      shape.id(this._createUniqueId());\n    }\n    \n    // Store shape for cleanup\n    this._shapes.set(shape.id(), {\n      shape,\n      layerName\n    });\n    \n    return shape;\n  }\n  \n  /**\n   * Add an existing shape to a layer\n   * @param {Object} shape - Konva shape\n   * @param {string} layerName - Layer name\n   * @returns {Object} The added shape\n   */\n  addShape(shape, layerName = 'main') {\n    // Get the target layer\n    const layer = this.getLayer(layerName);\n    if (!layer) return null;\n    \n    // Add shape to layer\n    layer.add(shape);\n    \n    // Register shape for tracking\n    return this._registerShape(shape, layerName);\n  }\n  \n  /**\n   * Add an existing group to a layer\n   * @param {Object} group - Konva group\n   * @param {string} layerName - Layer name\n   * @returns {Object} The added group\n   */\n  addGroup(group, layerName = 'main') {\n    // Get the target layer\n    const layer = this.getLayer(layerName);\n    if (!layer) return null;\n    \n    // Add group to layer\n    layer.add(group);\n    \n    // Register group for tracking\n    this._groups.set(group.id() || this._createUniqueId(), {\n      group,\n      layerName\n    });\n    \n    return group;\n  }\n  \n  /**\n   * Create and add a shape to a layer\n   * @param {string} type - Shape type (rect, circle, line, etc.)\n   * @param {Object} config - Shape configuration\n   * @param {string} layerName - Layer name\n   * @returns {Object} The created shape\n   * @private\n   */\n  _createShape(type, config, layerName = 'main') {\n    if (!this.renderEnv || !this.renderEnv.konva) {\n      console.error('Konva not available in rendering environment');\n      return null;\n    }\n    \n    const konva = this.renderEnv.konva;\n    \n    // Create shape based on type\n    let shape;\n    \n    switch (type.toLowerCase()) {\n      case 'rect':\n        shape = new konva.Rect(config);\n        break;\n      case 'circle':\n        shape = new konva.Circle(config);\n        break;\n      case 'ellipse':\n        shape = new konva.Ellipse(config);\n        break;\n      case 'line':\n        shape = new konva.Line(config);\n        break;\n      case 'path':\n        shape = new konva.Path(config);\n        break;\n      case 'text':\n        shape = new konva.Text(config);\n        break;\n      case 'regularpolygon':\n        shape = new konva.RegularPolygon(config);\n        break;\n      case 'star':\n        shape = new konva.Star(config);\n        break;\n      case 'image':\n        shape = new konva.Image(config);\n        break;\n      case 'polygon':\n        shape = new konva.Line({\n          ...config,\n          closed: true\n        });\n        break;\n      case 'group':\n        return this.createGroup(layerName);\n      default:\n        console.error(`Unknown shape type: ${type}`);\n        return null;\n    }\n    \n    // Add shape to layer\n    return this.addShape(shape, layerName);\n  }\n  \n  /**\n   * Create and add a rectangle shape\n   * @param {Object} config - Rectangle configuration\n   * @param {string} layerName - Layer name\n   * @returns {Object} The created rectangle\n   */\n  createRect(config, layerName = 'main') {\n    return this._createShape('rect', config, layerName);\n  }\n  \n  /**\n   * Create and add a circle shape\n   * @param {Object} config - Circle configuration\n   * @param {string} layerName - Layer name\n   * @returns {Object} The created circle\n   */\n  createCircle(config, layerName = 'main') {\n    return this._createShape('circle', config, layerName);\n  }\n  \n  /**\n   * Create and add a line shape\n   * @param {Object} config - Line configuration\n   * @param {string} layerName - Layer name\n   * @returns {Object} The created line\n   */\n  createLine(config, layerName = 'main') {\n    return this._createShape('line', config, layerName);\n  }\n  \n  /**\n   * Create and add a polygon shape\n   * @param {Object} config - Polygon configuration\n   * @param {string} layerName - Layer name\n   * @returns {Object} The created polygon\n   */\n  createPolygon(config, layerName = 'main') {\n    return this._createShape('polygon', config, layerName);\n  }\n  \n  /**\n   * Create and add a text shape\n   * @param {Object} config - Text configuration\n   * @param {string} layerName - Layer name\n   * @returns {Object} The created text\n   */\n  createText(config, layerName = 'main') {\n    return this._createShape('text', config, layerName);\n  }\n  \n  /**\n   * Create and add a path shape\n   * @param {Object} config - Path configuration\n   * @param {string} layerName - Layer name\n   * @returns {Object} The created path\n   */\n  createPath(config, layerName = 'main') {\n    return this._createShape('path', config, layerName);\n  }\n  \n  /**\n   * Create and add an image shape\n   * @param {Object} config - Image configuration\n   * @param {string} layerName - Layer name\n   * @returns {Object} The created image\n   */\n  createImage(config, layerName = 'main') {\n    return this._createShape('image', config, layerName);\n  }\n  \n  /**\n   * Create and add a group\n   * @param {string} layerName - Layer name\n   * @returns {Object} The created group\n   */\n  createGroup(layerName = 'main') {\n    const konva = this.renderEnv.konva;\n    if (!konva) {\n      console.error('Konva not available in rendering environment');\n      return null;\n    }\n    \n    // Create group\n    const group = new konva.Group({\n      id: this._createUniqueId()\n    });\n    \n    // Add to layer\n    return this.addGroup(group, layerName);\n  }\n  \n  /**\n   * Redraw a specific layer\n   * @param {string} layerName - Layer name\n   */\n  redrawLayer(layerName) {\n    const layer = this.getLayer(layerName);\n    if (layer && typeof layer.batchDraw === 'function') {\n      layer.batchDraw();\n    }\n  }\n  \n  /**\n   * Redraw all layers\n   */\n  redrawAllLayers() {\n    for (const layerName in this._layers) {\n      if (this._layers[layerName]) {\n        this.redrawLayer(layerName);\n      }\n    }\n  }\n  \n  /**\n   * Add an event handler to a shape\n   * @param {Object} shape - Konva shape or group\n   * @param {string} eventType - Event type (e.g., 'click', 'mouseover')\n   * @param {Function} handler - Event handler function\n   * @returns {boolean} Whether the handler was added successfully\n   */\n  addEventHandler(shape, eventType, handler) {\n    if (!shape || typeof shape.on !== 'function') {\n      console.error('Invalid shape for event handler');\n      return false;\n    }\n    \n    // Add event handler to shape\n    shape.on(eventType, handler);\n    \n    // Store binding for cleanup\n    this._eventBindings.push({\n      shape,\n      eventType,\n      handler\n    });\n    \n    return true;\n  }\n  \n  /**\n   * Remove an event handler\n   * @param {Object} shape - Konva shape or group\n   * @param {string} eventType - Event type\n   * @param {Function} handler - Event handler function\n   * @returns {boolean} Whether the handler was removed successfully\n   */\n  removeEventHandler(shape, eventType, handler) {\n    if (!shape || typeof shape.off !== 'function') {\n      return false;\n    }\n    \n    // Remove event handler from shape\n    shape.off(eventType, handler);\n    \n    // Remove from tracking\n    const index = this._eventBindings.findIndex(\n      binding => binding.shape === shape && \n                 binding.eventType === eventType && \n                 binding.handler === handler\n    );\n    \n    if (index !== -1) {\n      this._eventBindings.splice(index, 1);\n      return true;\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Implementation of the refresh method for 2D visualization\n   * @override\n   */\n  refresh() {\n    // Redraw all layers\n    this.redrawAllLayers();\n  }\n  \n  /**\n   * Extended unload method for 2D plugins\n   * @override\n   */\n  async unload() {\n    try {\n      // Clean up all tracked shapes\n      this._shapes.forEach(({ shape, layerName }) => {\n        if (shape && typeof shape.destroy === 'function') {\n          shape.destroy();\n        }\n      });\n      this._shapes.clear();\n      \n      // Clean up all tracked groups\n      this._groups.forEach(({ group, layerName }) => {\n        if (group && typeof group.destroy === 'function') {\n          group.destroy();\n        }\n      });\n      this._groups.clear();\n      \n      // Clean up all event bindings\n      this._eventBindings.forEach(binding => {\n        if (binding.shape && typeof binding.shape.off === 'function') {\n          binding.shape.off(binding.eventType, binding.handler);\n        }\n      });\n      this._eventBindings = [];\n      \n      // Clear layer cache\n      this._layers = {\n        background: null,\n        grid: null,\n        main: null,\n        overlay: null,\n        animation: null\n      };\n      \n      // Call the base class unload\n      return await super.unload();\n    } catch (error) {\n      console.error(`Error unloading 2D plugin ${this.id}:`, error);\n      return false;\n    }\n  }\n}\n","/**\n * Grid class for Mirror Curve application\n * Manages the grid structure and mirrors without any rendering dependencies\n */\nexport class Grid {\n  // Direction constants\n  static NW = 0;\n  static NE = 1;\n  static SW = 2;\n  static SE = 3;\n  \n  /**\n   * Create a new Grid\n   * @param {number} rows - Number of rows in the grid\n   * @param {number} cols - Number of columns in the grid\n   */\n  constructor(rows, cols) {\n    this.rows = rows;\n    this.cols = cols;\n    this.gridLines = new Map(); // Map of all grid lines\n    this.usedDirections = new Map(); // Map of used directions for each grid line\n    \n    // Initialize grid lines and connections\n    this.initializeGridLines();\n    this.computeConnections();\n    this.placeBoundaryMirrors(); // Place mirrors on all boundary grid lines\n    this.initializeUsedDirections(); // Mark appropriate directions as used\n  }\n\n  /**\n   * Create all horizontal and vertical grid lines\n   * Stores results in this.gridLines\n   */\n  initializeGridLines() {\n    // Create horizontal grid lines\n    for (let row = 0; row <= this.rows; row++) {\n      for (let col = 0; col < this.cols; col++) {\n        const id = this.generateGridLineId('h', row, col);\n        this.gridLines.set(id, {\n          id: id,\n          type: 'horizontal',\n          row: row,\n          col: col,\n          isMirror: false,\n          connections: { \n            [Grid.NW]: null, \n            [Grid.NE]: null, \n            [Grid.SW]: null, \n            [Grid.SE]: null \n          }\n        });\n      }\n    }\n    \n    // Create vertical grid lines\n    for (let row = 0; row < this.rows; row++) {\n      for (let col = 0; col <= this.cols; col++) {\n        const id = this.generateGridLineId('v', row, col);\n        this.gridLines.set(id, {\n          id: id,\n          type: 'vertical',\n          row: row,\n          col: col,\n          isMirror: false,\n          connections: { \n            [Grid.NW]: null, \n            [Grid.NE]: null, \n            [Grid.SW]: null, \n            [Grid.SE]: null \n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Place mirrors on all boundary grid lines\n   */\n  placeBoundaryMirrors() {\n    // Top boundary (horizontal lines at row 0)\n    for (let col = 0; col < this.cols; col++) {\n      const id = this.generateGridLineId('h', 0, col);\n      this.setMirror(id, true);\n    }\n    \n    // Bottom boundary (horizontal lines at row = this.rows)\n    for (let col = 0; col < this.cols; col++) {\n      const id = this.generateGridLineId('h', this.rows, col);\n      this.setMirror(id, true);\n    }\n    \n    // Left boundary (vertical lines at col 0)\n    for (let row = 0; row < this.rows; row++) {\n      const id = this.generateGridLineId('v', row, 0);\n      this.setMirror(id, true);\n    }\n    \n    // Right boundary (vertical lines at col = this.cols)\n    for (let row = 0; row < this.rows; row++) {\n      const id = this.generateGridLineId('v', row, this.cols);\n      this.setMirror(id, true);\n    }\n  }\n\n  /**\n   * Pre-compute connections between all grid lines\n   * This creates a navigation map for all four directions\n   */\n  computeConnections() {\n    // For each grid line\n    for (const gridLine of this.gridLines.values()) {\n      const { type, row, col } = gridLine;\n      \n      if (type === 'horizontal') {\n        // For horizontal lines\n        // NW connection - vertical line to the left\n        if (col >= 0 && row > 0) {\n          gridLine.connections[Grid.NW] = this.generateGridLineId('v', row - 1, col);\n        }\n        \n        // NE connection - vertical line to the right\n        if (row > 0) {\n          gridLine.connections[Grid.NE] = this.generateGridLineId('v', row - 1, col + 1);\n        }\n        \n        // SW connection - vertical line to the left (below)\n        if (col >= 0 && row < this.rows) {\n          gridLine.connections[Grid.SW] = this.generateGridLineId('v', row, col);\n        }\n        \n        // SE connection - vertical line to the right (below)\n        if (row < this.rows) {\n          gridLine.connections[Grid.SE] = this.generateGridLineId('v', row, col + 1);\n        }\n      } else {\n        // For vertical lines\n        // NW connection - horizontal line above\n        if (row >= 0 && col > 0) {\n          gridLine.connections[Grid.NW] = this.generateGridLineId('h', row, col - 1);\n        }\n        \n        // NE connection - horizontal line above (to the right)\n        if (row >= 0 && col < this.cols) {\n          gridLine.connections[Grid.NE] = this.generateGridLineId('h', row, col);\n        }\n        \n        // SW connection - horizontal line below\n        if (row < this.rows && col > 0) {\n          gridLine.connections[Grid.SW] = this.generateGridLineId('h', row + 1, col - 1);\n        }\n        \n        // SE connection - horizontal line below (to the right)\n        if (row < this.rows && col < this.cols) {\n          gridLine.connections[Grid.SE] = this.generateGridLineId('h', row + 1, col);\n        }\n      }\n      \n      // Validate connections (remove those that point outside the grid)\n      //for (const direction in gridLine.connections) {\n      //  const connId = gridLine.connections[direction];\n      //  if (connId !== null && !this.gridLines.has(connId)) {\n      //    gridLine.connections[direction] = null;\n      //  }\n      //}\n    }\n  }\n\n  /**\n   * Initialize the tracking of used directions\n   * For boundary mirrors, marks the specific directions as used according to their position\n   */\n  initializeUsedDirections() {\n    // Initialize empty sets for all grid lines\n    for (const [id, gridLine] of this.gridLines.entries()) {\n      this.usedDirections.set(id, new Set());\n    }\n    \n    // Set used directions for boundary mirrors as specified\n    for (const [id, gridLine] of this.gridLines.entries()) {\n      // If it's not a boundary line, all directions are initially available\n      if (!this.isBoundaryGridLine(gridLine)) {\n        continue;\n      }\n      \n      // Mark the appropriate directions as used based on the boundary position\n      if (gridLine.type === 'horizontal') {\n        if (gridLine.row === 0) {\n          // Horizontal top - NW NE are used\n          this.usedDirections.get(id).add(Grid.NW);\n          this.usedDirections.get(id).add(Grid.NE);\n        } else if (gridLine.row === this.rows) {\n          // Horizontal bottom - SW SE are used\n          this.usedDirections.get(id).add(Grid.SW);\n          this.usedDirections.get(id).add(Grid.SE);\n        }\n      } else { // vertical\n        if (gridLine.col === 0) {\n          // Vertical left - SW NW are used\n          this.usedDirections.get(id).add(Grid.SW);\n          this.usedDirections.get(id).add(Grid.NW);\n        } else if (gridLine.col === this.cols) {\n          // Vertical right - NE SE are used\n          this.usedDirections.get(id).add(Grid.NE);\n          this.usedDirections.get(id).add(Grid.SE);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if a grid line is on the boundary\n   * @param {Object} gridLine - The grid line to check\n   * @returns {boolean} True if the grid line is on the boundary\n   */\n  isBoundaryGridLine(gridLine) {\n    if (!gridLine) return false;\n    \n    const { type, row, col } = gridLine;\n    \n    if (type === 'horizontal') {\n      return row === 0 || row === this.rows;\n    } else { // vertical\n      return col === 0 || col === this.cols;\n    }\n  }\n\n  /**\n   * Retrieve a grid line by its ID\n   * @param {string} id - Grid line ID\n   * @returns {Object|null} The grid line or null if not found\n   */\n  getGridLine(id) {\n    return this.gridLines.get(id) || null;\n  }\n\n  /**\n   * Get the adjacent grid line ID in the specified direction\n   * @param {string} lineId - Starting grid line ID\n   * @param {number} direction - Direction (use Grid.NW, Grid.NE, etc.)\n   * @returns {string|null} ID of the adjacent grid line or null if none\n   * @throws {Error} If trying to move outside the grid\n   */\n  getAdjacentGridLine(lineId, direction) {\n    const gridLine = this.getGridLine(lineId);\n    if (!gridLine) return null;\n    \n    // Make sure direction is valid\n    if (![Grid.NW, Grid.NE, Grid.SW, Grid.SE].includes(direction)) {\n      return null;\n    }\n    \n    const nextLineId = gridLine.connections[direction];\n    \n    // Check if this move would leave the grid\n    if (nextLineId === null) {\n      throw new Error(\"Curve left the grid\");\n    }\n    \n    return nextLineId;\n  }\n\n  /**\n   * Set the mirror status of a grid line\n   * @param {string} lineId - Grid line ID\n   * @param {boolean} isMirror - Whether this line should be a mirror\n   */\n  setMirror(lineId, isMirror) {\n    const gridLine = this.getGridLine(lineId);\n    if (gridLine) {\n      gridLine.isMirror = isMirror;\n    }\n  }\n\n  /**\n   * Get the reflected direction when a ray hits a mirror\n   * @param {string} gridLineId - ID of the grid line (mirror)\n   * @param {number} incomingDirection - Direction (use Grid.NW, Grid.NE, etc.)\n   * @returns {number} Reflected direction\n   */\n  getReflectedDirection(gridLineId, incomingDirection) {\n    const gridLine = this.getGridLine(gridLineId);\n    if (!gridLine) return incomingDirection;\n    \n    // If not a mirror, just continue in the same direction\n    if (!gridLine.isMirror) {\n      return incomingDirection;\n    }\n    \n    // Calculate reflection based on line orientation and incoming direction\n    // For horizontal mirrors: NW <-> SW, NE <-> SE\n    // For vertical mirrors: NW <-> NE, SW <-> SE\n    \n    if (gridLine.type === 'horizontal') {\n      switch (incomingDirection) {\n        case Grid.NW: return Grid.SW;\n        case Grid.NE: return Grid.SE;\n        case Grid.SW: return Grid.NW;\n        case Grid.SE: return Grid.NE;\n        default: return incomingDirection;\n      }\n    } else { // vertical\n      switch (incomingDirection) {\n        case Grid.NW: return Grid.NE;\n        case Grid.NE: return Grid.NW;\n        case Grid.SW: return Grid.SE;\n        case Grid.SE: return Grid.SW;\n        default: return incomingDirection;\n      }\n    }\n  }\n\n  /**\n   * Mark a direction as used for a grid line\n   * @param {string} gridLineId - Grid line ID\n   * @param {number} direction - Direction (use Grid.NW, Grid.NE, etc.)\n   */\n  markDirectionUsed(gridLineId, direction) {\n    if (this.usedDirections.has(gridLineId)) {\n      this.usedDirections.get(gridLineId).add(direction);\n    }\n  }\n\n  /**\n   * Check if a direction is already used for a grid line\n   * @param {string} gridLineId - Grid line ID\n   * @param {number} direction - Direction (use Grid.NW, Grid.NE, etc.)\n   * @returns {boolean} True if the direction is already used\n   */\n  isDirectionUsed(gridLineId, direction) {\n    if (!this.usedDirections.has(gridLineId)) {\n      return false;\n    }\n    return this.usedDirections.get(gridLineId).has(direction);\n  }\n\n  /**\n   * Get all unused directions for a grid line\n   * @param {string} gridLineId - Grid line ID\n   * @returns {number[]} Array of available directions\n   */\n  getUnusedDirections(gridLineId) {\n    const allDirections = [Grid.NW, Grid.NE, Grid.SW, Grid.SE];\n    const gridLine = this.getGridLine(gridLineId);\n    \n    if (!gridLine || !this.usedDirections.has(gridLineId)) {\n      return [];\n    }\n    \n    const usedDirs = this.usedDirections.get(gridLineId);\n    const validDirs = allDirections.filter(dir => {\n      // Filter out directions where connection is null\n      //if (gridLine.connections[dir] === null) {\n        //return false;\n      //}\n      // Filter out directions that are already used\n      if (usedDirs.has(dir)) {\n        return false;\n      }\n      return true;\n    });\n    \n    return validDirs;\n  }\n\n  /**\n   * Reset all used directions\n   * Re-initializes with the correct boundary mirror directions\n   */\n  resetUsedDirections() {\n    this.initializeUsedDirections();\n  }\n\n  /**\n   * Check if a direction from a grid line leads off the grid\n   * @param {string} gridLineId - Grid line ID\n   * @param {number} direction - Direction (use Grid.NW, Grid.NE, etc.)\n   * @returns {boolean} True if the direction leads off the grid\n   */\n  isEdgeDirection(gridLineId, direction) {\n    const gridLine = this.getGridLine(gridLineId);\n    if (!gridLine) return true;\n    \n    // Make sure direction is valid\n    if (![Grid.NW, Grid.NE, Grid.SW, Grid.SE].includes(direction)) {\n      return true;\n    }\n    \n    return gridLine.connections[direction] === null;\n  }\n\n  /**\n   * Get the number of mirrors in the grid\n   * @returns {number} Number of mirrors\n   */\n  getMirrorCount() {\n    let count = 0;\n    for (const gridLine of this.gridLines.values()) {\n      if (gridLine.isMirror) count++;\n    }\n    return count;\n  }\n\n    /**\n     * Randomly toggles each interior mirror line with probability p.\n     * Boundary lines (all of which are always mirrors) are left unchanged.\n     * @param {number} p – probability in [0,1] of toggling each line’s mirror state\n     */\n    randomizeMirrors(p) {\n\tif (p < 0 || p > 1) {\n\t    throw new Error(\"Probability must be between 0 and 1\");\n\t}\n\n\tconsole.log(\"Put Mirror with probability\", p);\n\n\tfor (const [id, gridLine] of this.gridLines.entries()) {\n\t    // skip boundary lines\n\t    const { type, row, col } = this.parseGridLineId(id);\n\t    const isBoundary =\n\t\t  (type === 'h' && (row === 0 || row === this.rows)) ||\n\t\t  (type === 'v' && (col === 0 || col === this.cols));\n\t    if (isBoundary) continue;\n\n\t    // with probability p, flip its mirror status\n\t    if (Math.random() < p) {\n\t\tthis.setMirror(id, true);\n\t    }\n\t    else {\n\t\tthis.setMirror(id,false);\n\t    }\n\t}\n    }\n\n  /**\n   * Generate a standard grid line ID\n   * @param {string} type - 'h' for horizontal, 'v' for vertical\n   * @param {number} row - Row index\n   * @param {number} col - Column index\n   * @returns {string} Formatted ID string\n   */\n  generateGridLineId(type, row, col) {\n    return `${type}_${row}_${col}`;\n  }\n\n  /**\n   * Parse components from a grid line ID\n   * @param {string} id - Grid line ID\n   * @returns {Object} Object with type, row, and col properties\n   */\n  parseGridLineId(id) {\n    const parts = id.split('_');\n    return {\n      type: parts[0],\n      row: parseInt(parts[1], 10),\n      col: parseInt(parts[2], 10)\n    };\n  }\n}\n","/**\n * MirrorCurve class for Mirror Curve application\n * Represents a curve that traverses a grid following mirror reflection rules\n */\n\nimport { Grid } from \"./grid.js\";\nexport class MirrorCurve {\n  /**\n   * Create a new MirrorCurve\n   * @param {Object} startGridLine - The starting grid line\n   * @param {number} initialDirection - Initial direction (use Grid.NW, Grid.NE, etc.)\n   */\n  constructor(startGridLine, initialDirection) {\n    // Store the grid lines that form the curve\n    this.gridLines = [startGridLine];\n    \n    // Store the directions after each grid line\n    this.directions = [initialDirection];\n    \n    // Track if the curve is a closed loop\n    this.isClosed = false;\n    \n    // Track if the curve left the grid\n    this.leftGrid = false;\n    \n    // Store exit point and direction if curve leaves grid\n    this.exitPoint = null;\n    this.exitDirection = null;\n  }\n  \n  /**\n   * Add a segment to the curve\n   * @param {Object} nextGridLine - The next grid line to add\n   * @param {number} nextDirection - The direction after this grid line\n   */\n  addSegment(nextGridLine, nextDirection) {\n    this.gridLines.push(nextGridLine);\n    this.directions.push(nextDirection);\n  }\n  \n  /**\n   * Build the complete curve by traversing the grid\n   * @param {Grid} grid - The grid object containing mirrors and connectivity\n   * @returns {boolean} - True if the curve was successfully built\n   */\n    buildCurve(grid) {\n    // Maximum number of segments to prevent infinite loops\n    const MAX_SEGMENTS = 1000000;\n    \n    // Mark the initial direction as used\n    let currentGridLine = this.gridLines[0];\n    let currentDirection = this.directions[0];\n    grid.markDirectionUsed(currentGridLine.id, currentDirection);\n    \n    // Build the curve until it forms a loop or reaches an edge\n    while (this.gridLines.length < MAX_SEGMENTS) {\n      try {\n        // Get the next grid line in the current direction\n        const nextLineId = grid.getAdjacentGridLine(currentGridLine.id, currentDirection);\n        \n        // If getAdjacentGridLine returned null, we'd already be in the catch block\n        // So if we're here, we have a valid next line\n        const nextGridLine = grid.getGridLine(nextLineId);\n        \n        // If the next line doesn't exist for some reason, stop\n        if (!nextGridLine) {\n          console.warn(`Invalid grid line returned: ${nextLineId}`);\n          return false;\n        }\n        \n        // Determine the next direction based on whether the line is a mirror\n        let nextDirection = currentDirection;\n        if (nextGridLine.isMirror) {\n          nextDirection = grid.getReflectedDirection(nextLineId, currentDirection);\n        }\n        \n        // Add the segment to the curve\n          this.addSegment(nextGridLine, nextDirection);\n\n\t  \n          // Mark the outgoingdirection as used\n\t  grid.markDirectionUsed(nextLineId, nextDirection);\n\t  const oppositeDirection = currentDirection === Grid.NW ? Grid.SE\n\t\t: currentDirection === Grid.SE ? Grid.NW\n\t\t: currentDirection === Grid.NE ? Grid.SW\n\t\t: /* else SW */             Grid.NE;\n\t  \n\t  // Mark that incoming direction as used\n\t  grid.markDirectionUsed(\n\t      nextLineId,\n\t      oppositeDirection);\n\n          \n        // Check if we've formed a loop back to the start\n        if (this.gridLines.length > 2) { // Need at least 3 points for a meaningful loop\n          // Check if we're back at the starting point with matching direction\n          if (nextGridLine.id === this.gridLines[0].id && \n              nextDirection === this.directions[0]) {\n            this.isClosed = true;\n            return true;\n          }\n        }\n        \n        \n        \n        // Update current position for next iteration\n        currentGridLine = nextGridLine;\n        currentDirection = nextDirection;\n      }\n      catch (error) {\n        // If we get \"Curve left the grid\" error, mark it and record exit information\n        if (error.message === \"Curve left the grid\") {\n          this.leftGrid = true;\n          this.exitPoint = currentGridLine;\n          this.exitDirection = currentDirection;\n          return true; // Successfully built curve, it just left the grid\n        }\n        // For any other error, propagate it\n        throw error;\n      }\n    }\n    \n    // If we reach here, we hit the maximum number of segments\n    console.warn('Maximum segments reached without forming a loop');\n    return false;\n  }\n  \n  /**\n   * Generate a string representation of the curve\n   * @returns {string} Formatted representation of the curve\n   */\n  toString() {\n    const directionNames = ['NW', 'NE', 'SW', 'SE'];\n    let result = 'MirrorCurve:\\n';\n    \n    for (let i = 0; i < this.gridLines.length; i++) {\n      const gridLine = this.gridLines[i];\n      const direction = directionNames[this.directions[i]];\n      \n      result += `  ${gridLine.id} -> ${direction}\\n`;\n    }\n    \n    if (this.isClosed) {\n      result += '  (Closed loop)';\n    } else if (this.leftGrid) {\n      result += `  (Left grid at ${this.exitPoint.id} in direction ${directionNames[this.exitDirection]})`;\n    } else {\n      result += '  (Open path)';\n    }\n    \n    return result;\n  }\n}\n","/**\n * CurveFinder - Simple helper functions to find mirror curves on a grid\n */\nimport { MirrorCurve } from './mirrorCurve.js';\nimport { Grid } from './grid.js';\n\n/**\n * Find the next available curve in a grid\n * @param {Grid} grid - The grid object containing mirrors\n * @returns {MirrorCurve|null} The next available curve or null if none\n */\nexport function findNextCurve(grid) {\n  console.log('Looking for the next available curve...');\n  \n  // Find any grid line that has a mirror and an unused direction\n  for (const [id, gridLine] of grid.gridLines.entries()) {\n \n    // Get unused directions for this grid line\n    const unusedDirections = grid.getUnusedDirections(id);\n    \n    // If there are unused directions, create a curve with the first one\n    if (unusedDirections.length > 0) {\n      const direction = unusedDirections[0];\n      console.log(`Starting curve from ${id} in direction ${direction}`);\n      \n      // Create a new curve\n      const curve = new MirrorCurve(gridLine, direction);\n      \n      try {\n          // Build the curve\n        const success = curve.buildCurve(grid);\n        \n        if (success) {\n          console.log(`Built curve with ${curve.gridLines.length} segments (${curve.isClosed ? 'closed loop' : 'open path'})`);\n          return curve;\n        }\n      } catch (error) {\n        console.error(`Error building curve from ${id} in direction ${direction}:`, error);\n        // Continue with the next grid line\n      }\n    }\n  }\n  \n  console.log('No more curves available');\n  return null;\n}\n\n/**\n * Find all possible curves in a grid\n * @param {Grid} grid - The grid object containing mirrors\n * @returns {Array<MirrorCurve>} Array of all unique mirror curves\n */\nexport function findAllCurves(grid) {\n  const curves = [];\n  \n  // Reset used directions\n  grid.resetUsedDirections();\n  \n  // Keep finding curves until there are no more\n  let curve;\n  while ((curve = findNextCurve(grid)) !== null) {\n    curves.push(curve);\n  }\n  \n  return curves;\n}\n","// plugins/mirror-curve/gridRenderer.js\n\nexport class GridRenderer {\n  constructor(konva) {\n    this.konva = konva;\n    this.styleSettings = {\n      lineStyles: {\n        grid: { width: 1 },\n        gridPoint: { radius: 2 },\n        mirror: { width: 2 },\n        centerDot: { radius: 3 }\n      }\n    };\n  }\n\n  renderGrid(grid, group, options) {\n    const {\n      cellSize = 1,\n      showGridLines = true,\n      showGridPoints = true,\n      showMirrors = true,\n      showCenterDots = false,\n      gridLineColor = '#cccccc',\n      mirrorColor = '#333333'\n    } = options;\n\n    // Clear the group\n    group.destroyChildren();\n\n    // Draw grid lines\n    if (showGridLines) {\n      for (const line of grid.gridLines.values()) {\n        const x1 = line.col * cellSize;\n        const y1 = line.row * cellSize;\n        const x2 = (line.type === 'horizontal' ? (line.col + 1) * cellSize : x1);\n        const y2 = (line.type === 'vertical' ? (line.row + 1) * cellSize : y1);\n        \n        const lineObj = new this.konva.Line({\n          points: [x1, y1, x2, y2],\n          stroke: gridLineColor,\n          strokeWidth: this.styleSettings.lineStyles.grid.width\n        });\n        \n        group.add(lineObj);\n      }\n    }\n    \n    // Draw grid points\n    if (showGridPoints) {\n      for (let r = 0; r <= grid.rows; r++) {\n        for (let c = 0; c <= grid.cols; c++) {\n          const circle = new this.konva.Circle({\n            x: c * cellSize,\n            y: r * cellSize,\n            radius: this.styleSettings.lineStyles.gridPoint.radius,\n            fill: gridLineColor\n          });\n          \n          group.add(circle);\n        }\n      }\n    }\n    \n    // Draw mirror lines\n    if (showMirrors) {\n      for (const line of grid.gridLines.values()) {\n        if (!line.isMirror) continue;\n        \n        const x1 = line.col * cellSize;\n        const y1 = line.row * cellSize;\n        const x2 = (line.type === 'horizontal' ? (line.col + 1) * cellSize : x1);\n        const y2 = (line.type === 'vertical' ? (line.row + 1) * cellSize : y1);\n        \n        const mirrorLine = new this.konva.Line({\n          points: [x1, y1, x2, y2],\n          stroke: mirrorColor,\n          strokeWidth: this.styleSettings.lineStyles.mirror.width\n        });\n        \n        group.add(mirrorLine);\n      }\n    }\n    \n    // Draw center dots\n    if (showCenterDots) {\n      for (let r = 0; r < grid.rows; r++) {\n        for (let c = 0; c < grid.cols; c++) {\n          const centerDot = new this.konva.Circle({\n            x: (c + 0.5) * cellSize,\n            y: (r + 0.5) * cellSize,\n            radius: this.styleSettings.lineStyles.centerDot.radius,\n            fill: mirrorColor\n          });\n          \n          group.add(centerDot);\n        }\n      }\n    }\n  }\n}\n","/**\n * src/drawing/spline.js\n * Spline interpolation routines for the Mirror-Curve application.\n * Implements cyclic Catmull-Rom interpolation using a tension parameter.\n *\n * Exports:\n *  - getSplinePoints(rawPoints: Point[], tension: number): Point[]\n */\n\n// Linear interpolation between two scalars\nfunction lerp(a, b, t) {\n  return a + (b - a) * t;\n}\n\n// Subdivide a single curve segment using cubic Hermite basis\nfunction segmentSubdivision(P0, P1, M0, M1, subdivisions) {\n  const pts = [];\n  for (let j = 0; j < subdivisions; j++) {\n    const t = j / subdivisions;\n    const t2 = t * t;\n    const t3 = t2 * t;\n\n    // Hermite basis functions\n    const h00 = 2 * t3 - 3 * t2 + 1;\n    const h10 = t3 - 2 * t2 + t;\n    const h01 = -2 * t3 + 3 * t2;\n    const h11 = t3 - t2;\n\n    // Interpolated point\n    const x = h00 * P0.x + h10 * M0.x + h01 * P1.x + h11 * M1.x;\n    const y = h00 * P0.y + h10 * M0.y + h01 * P1.y + h11 * M1.y;\n\n    pts.push({ x, y });\n  }\n  return pts;\n}\n\n/**\n * Generate Catmull-Rom spline points for cyclic rawPoints.\n *\n * @param {Array<{x:number,y:number}>} rawPoints - Input control points in cyclic order.\n * @param {number} tension - Tension parameter (0 = standard Catmull-Rom, 1 = linear).\n * @param {number} [subdivisions=10] - Number of interpolated points per segment.\n * @returns {Array<{x:number,y:number}>} - Array of interpolated points closing the loop.\n */\nexport function getSplinePoints(rawPoints, tension = 0.5, subdivisions = 10) {\n  const N = rawPoints.length;\n  if (N < 2) {\n    return rawPoints.slice();\n  }\n  \n  // Check if the curve is already closed (first point equals last point)\n  const alreadyClosed = (N > 1 && \n    Math.abs(rawPoints[0].x - rawPoints[N-1].x) < 0.001 && \n    Math.abs(rawPoints[0].y - rawPoints[N-1].y) < 0.001);\n  \n  // If already closed, don't include the last point in the spline generation\n  // to avoid doubling up on the start/end point\n  const effectivePoints = alreadyClosed ? rawPoints.slice(0, N-1) : rawPoints;\n  const numPoints = effectivePoints.length;\n  \n  // Compute tangents with adjusted tension\n  const tangents = [];\n  for (let i = 0; i < numPoints; i++) {\n    const prev = effectivePoints[(i - 1 + numPoints) % numPoints];\n    const next = effectivePoints[(i + 1) % numPoints];\n    tangents.push({\n      x: ((next.x - prev.x) * (1 - tension)) / 2,\n      y: ((next.y - prev.y) * (1 - tension)) / 2\n    });\n  }\n\n  const curve = [];\n  \n  // Build each segment\n  for (let i = 0; i < numPoints; i++) {\n    const P0 = effectivePoints[i];\n    const P1 = effectivePoints[(i + 1) % numPoints];\n    const M0 = tangents[i];\n    const M1 = tangents[(i + 1) % numPoints];\n\n    // For the last segment of an open curve, we only go to the last point\n    // Otherwise, we subdivide normally\n    const segment = segmentSubdivision(P0, P1, M0, M1, subdivisions);\n    \n    // Only add the subdivided points for this segment\n    // (except the last one, which will be the first point of the next segment)\n    if (i < numPoints - 1 || alreadyClosed) {\n      curve.push(...segment);\n    } else {\n      // For the last segment of an open curve, include the final point\n      curve.push(...segment);\n    }\n  }\n  \n  // For closed curves, explicitly add the first point to ensure perfect closure\n  if (alreadyClosed) {\n    curve.push({ \n      x: effectivePoints[0].x, \n      y: effectivePoints[0].y \n    });\n  }\n  \n  return curve;\n}\n","// plugins/mirror-curve/helperPointCalculator.js\n\n/**\n * Calculate a helper point for a grid line with directional offset\n * @param {Object} line - The grid line object \n * @param {number} direction - Direction value (0=NW, 1=NE, 2=SW, 3=SE)\n * @param {number} cellSize - Size of a grid cell\n * @returns {Object} - Point coordinates {x, y}\n */\nexport function findHelperPoint(line, direction, cellSize) {\n  // Get the basic midpoint\n  let x, y;\n  if (line.type === 'horizontal') {\n    x = (line.col + 0.5) * cellSize;\n    y = line.row * cellSize;\n  } else { // vertical\n    x = line.col * cellSize;\n    y = (line.row + 0.5) * cellSize;\n  }\n  \n  // Only apply offset if the line is a mirror\n  if (line.isMirror) {\n    // Calculate offset distance\n    const d = cellSize / 6;\n    \n    if (line.type === 'vertical') {\n      if (direction === 1 || direction === 3) { // NE or SE\n        x += d;\n      } else if (direction === 0 || direction === 2) { // NW or SW\n        x -= d;\n      }\n    } else { // horizontal\n      if (direction === 0 || direction === 1) { // NW or NE\n        y -= d;\n      } else if (direction === 2 || direction === 3) { // SW or SE\n        y += d;\n      }\n    }\n  }\n  \n  return { x, y };\n}\n\n/**\n * Calculate helper points for all curves\n * @param {Array} curves - Array of curves\n * @param {number} cellSize - Cell size\n * @returns {Array} Array of helper points for each curve\n */\nexport function calculateAllHelperPoints(curves, cellSize) {\n  const allHelperPoints = [];\n  \n  curves.forEach(curve => {\n    if (curve.isCompleted && curve.gridLines && Array.isArray(curve.gridLines)) {\n      const helperPointsForCurve = curve.gridLines.map((line, index) => {\n        const direction = curve.directions[index];\n        const point = findHelperPoint(line, direction, cellSize);\n        return { ...point, curveIndex: allHelperPoints.length };\n      });\n      \n      allHelperPoints.push(helperPointsForCurve);\n    }\n  });\n  \n  return allHelperPoints;\n}\n","// plugins/mirror-curve/curveRenderer.js\nimport { getSplinePoints } from './spline.js';\nimport { findHelperPoint } from './helperPointCalculator.js';\n\n/**\n * Calculate appropriate number of subdivisions based on grid size\n * @param {number} rows - Number of grid rows\n * @param {number} cols - Number of grid columns\n * @param {boolean} isAnimation - Whether this is for animation (needs fewer points)\n * @returns {number} Number of subdivisions to use\n */\nfunction calculateSubdivisions(rows, cols, isAnimation = false) {\n    // Calculate grid complexity\n    const cellCount = rows * cols;\n    \n    // Base values\n    const baseSubdivisions = 8;\n    \n    // For small grids (less than 25 cells), use more subdivisions\n    if (cellCount <= 25) {\n        return baseSubdivisions + 4;\n    }\n    \n    // For medium grids (26-100 cells), use standard subdivisions\n    if (cellCount <= 100) {\n        return baseSubdivisions + 2;\n    }\n    \n    // For large grids (101-400 cells), reduce subdivisions\n    if (cellCount <= 400) {\n        return Math.max(3, baseSubdivisions - 2);\n    }\n    \n    // For very large grids (over 400 cells), use minimum subdivisions\n    return Math.max(2, baseSubdivisions - 4);\n}\n\nexport class CurveRenderer {\n    constructor(konva) {\n        this.konva = konva;\n        this.styleSettings = {\n            lineStyles: {\n                curve: { width: 3 },\n                helperPoint: { radius: 4 }\n            }\n        };\n        \n        // Cache for animation points to avoid recalculating full paths\n        this.animationCache = new Map();\n    }\n\n    renderCurves(curves, group, options) {\n        // Clear the group\n        group.destroyChildren();\n        \n        const {\n            cellSize = 1,\n            colorScheme = ['#3498db'], \n            curveStyle = 'curved',\n            tension = 0,\n            smooth = true,\n            showHelperPoints = false,\n            helperPointColor = '#ff0000',\n            animationPath = null,\n            helperPoints = [],\n            gridRows = 5,  // Add grid dimensions for dynamic subdivision\n            gridCols = 5\n        } = options;\n        \n        // Draw completed curves\n        curves.forEach((curve, idx) => {\n            const konvaCurve = this.createKonvaCurve(curve, idx, cellSize, colorScheme, {\n                curveStyle, \n                tension, \n                smooth,\n                gridRows,\n                gridCols\n            });\n            \n            if (konvaCurve) {\n                group.add(konvaCurve);\n            }\n        });\n        \n        // Draw animation path if it exists\n        if (animationPath) {\n            const animCurve = this.createKonvaCurve(\n                animationPath, \n                curves.length, \n                cellSize, \n                colorScheme,\n                { \n                    curveStyle, \n                    tension, \n                    smooth,\n                    gridRows,\n                    gridCols\n                }\n            );\n            \n            if (animCurve) {\n                group.add(animCurve);\n            }\n        }\n        \n        // Draw helper points if enabled\n        if (showHelperPoints) {\n            const helperPointRadius = this.styleSettings.lineStyles.helperPoint.radius;\n            \n            // Add helper points for all curves\n            helperPoints.forEach(curvePoints => {\n                curvePoints.forEach(point => {\n                    const helperPoint = new this.konva.Circle({\n                        x: point.x,\n                        y: point.y,\n                        radius: helperPointRadius,\n                        fill: helperPointColor\n                    });\n                    \n                    group.add(helperPoint);\n                });\n            });\n        }\n    }\n\n    createKonvaCurve(curve, idx, cellSize, colorScheme, options) {\n        if (!curve) return null;\n        \n        const { \n            curveStyle = 'curved', \n            tension = 0, \n            smooth = true,\n            gridRows = 5,\n            gridCols = 5\n        } = options;\n        \n        // Extract points from the curve\n        let points = [];\n        let isClosed = false;\n        \n        // Parse the points based on curve type\n        if (curve.type === 'animationPath') {\n            points = curve.points || [];\n            isClosed = curve.isClosed || false;\n        }\n        else if (curve.gridLines && Array.isArray(curve.gridLines)) {\n            isClosed = curve.isClosed || false;\n            \n            // Generate points based on curve style\n            if (curveStyle === 'curved') {\n                // Calculate helper points with offsets for smooth curves\n                const helperPointsForCurve = curve.gridLines.map((line, index) => {\n                    const direction = curve.directions[index];\n                    return findHelperPoint(line, direction, cellSize);\n                });\n                \n                // Calculate dynamic subdivision based on grid size\n                const subdivisions = calculateSubdivisions(gridRows, gridCols, false);\n                \n                // Apply spline for smooth curves with dynamic subdivisions\n                points = getSplinePoints(helperPointsForCurve, tension, subdivisions);\n            } else {\n                // Use regular midpoints for jagged style\n                points = curve.gridLines.map(line => {\n                    if (line.type === 'horizontal') {\n                        return {\n                            x: (line.col + 0.5) * cellSize,\n                            y: line.row * cellSize\n                        };\n                    } else { // vertical\n                        return {\n                            x: line.col * cellSize,\n                            y: (line.row + 0.5) * cellSize\n                        };\n                    }\n                });\n            }\n        }\n        \n        // Skip if no points\n        if (points.length === 0) return null;\n        \n        // Convert points to flat array for Konva\n        const flatPoints = [];\n        points.forEach(point => {\n            flatPoints.push(point.x, point.y);\n        });\n        \n        // Create Konva line\n        const curveWidth = this.styleSettings.lineStyles.curve.width;\n        const color = colorScheme[idx % colorScheme.length];\n        \n        const konvaLine = new this.konva.Line({\n            points: flatPoints,\n            stroke: color,\n            strokeWidth: curveWidth,\n            lineCap: 'round',\n            lineJoin: 'round',\n            closed: isClosed\n        });\n        \n        return konvaLine;\n    }\n    \n    createAnimationPathByDistance(curve, cellSize, distance, options = {}) {\n        if (!curve || !curve.gridLines || curve.gridLines.length === 0) {\n            return null;\n        }\n        \n        const { \n            tension = 0.5,\n            curveStyle = 'curved',\n            smooth = true,\n            gridRows = 5,  // Add grid dimensions for dynamic subdivision\n            gridCols = 5\n        } = options;\n        \n        // Create a unique key for this curve and settings combination\n        const curveKey = `${curve.gridLines[0].id}-${tension}-${curveStyle}`;\n        \n        // Check if we already computed the full curve points\n        let allSplinePoints = null;\n        let totalLength = 0;\n        let segmentLengths = [];\n        \n        if (this.animationCache.has(curveKey)) {\n            // Use cached data\n            const cachedData = this.animationCache.get(curveKey);\n            allSplinePoints = cachedData.points;\n            totalLength = cachedData.totalLength;\n            segmentLengths = cachedData.segmentLengths;\n        } else {\n            // First time - calculate all points for the full curve\n            \n            // Calculate dynamic subdivision based on grid size\n            const animSubdivisions = calculateSubdivisions(gridRows, gridCols, true);\n            \n            // Get all helper points for the full curve\n            const allHelperPoints = curve.gridLines.map((line, index) => {\n                const direction = curve.directions[index];\n                return findHelperPoint(line, direction, cellSize);\n            });\n            \n            // Generate the complete spline path with dynamic subdivisions\n            allSplinePoints = getSplinePoints(allHelperPoints, tension, animSubdivisions);\n            \n            // Calculate total length and segment lengths\n            totalLength = 0;\n            segmentLengths = [];\n            \n            for (let i = 1; i < allSplinePoints.length; i++) {\n                const dx = allSplinePoints[i].x - allSplinePoints[i-1].x;\n                const dy = allSplinePoints[i].y - allSplinePoints[i-1].y;\n                const segmentLength = Math.sqrt(dx*dx + dy*dy);\n                \n                segmentLengths.push(segmentLength);\n                totalLength += segmentLength;\n            }\n            \n            // Cache the results\n            this.animationCache.set(curveKey, {\n                points: allSplinePoints,\n                totalLength,\n                segmentLengths\n            });\n        }\n        \n        if (allSplinePoints.length < 2) {\n            return { completed: true };\n        }\n        \n        // If the curve has no real length, consider it completed\n        if (totalLength < 0.001) {\n            return { completed: true };\n        }\n        \n        // Cap the distance at the total length\n        const cappedDistance = Math.min(distance, totalLength);\n        \n        // Find up to which point we should draw\n        let currentLength = 0;\n        let segmentIndex = 0;\n        \n        // Find the segment where our current distance falls\n        while (segmentIndex < segmentLengths.length && currentLength + segmentLengths[segmentIndex] < cappedDistance) {\n            currentLength += segmentLengths[segmentIndex];\n            segmentIndex++;\n        }\n        \n        // Include all complete segments\n        const visiblePoints = allSplinePoints.slice(0, segmentIndex + 1);\n        \n        // If we're not at the end, add the partial segment point\n        if (segmentIndex < segmentLengths.length) {\n            const remainingDistance = cappedDistance - currentLength;\n            const segmentFraction = remainingDistance / segmentLengths[segmentIndex];\n            \n            const lastPoint = allSplinePoints[segmentIndex];\n            const nextPoint = allSplinePoints[segmentIndex + 1];\n            \n            // Linear interpolation for the partial segment\n            const interpPoint = {\n                x: lastPoint.x + (nextPoint.x - lastPoint.x) * segmentFraction,\n                y: lastPoint.y + (nextPoint.y - lastPoint.y) * segmentFraction\n            };\n            \n            // Add the interpolated point\n            visiblePoints.push(interpPoint);\n        }\n        \n        // Check if animation is complete\n        if (cappedDistance >= totalLength) {\n            return { completed: true };\n        }\n        \n        return {\n            type: 'animationPath',\n            points: visiblePoints,\n            isClosed: false,\n            completed: false,\n            totalLength: totalLength // Store for reference\n        };\n    }\n\n    // Clear animation cache when no longer needed\n    clearCache() {\n        this.animationCache.clear();\n    }\n    \n    // Clear a specific curve from the cache\n    clearCurveFromCache(curveId) {\n        // Find and remove entries that start with this curve ID\n        for (const key of this.animationCache.keys()) {\n            if (key.startsWith(curveId)) {\n                this.animationCache.delete(key);\n            }\n        }\n    }\n}\n","// plugins/mirror-curve/index.js\nimport { Plugin2D } from '../../core/Plugin2D.js';\nimport { Grid } from './grid.js';\nimport { findNextCurve, findAllCurves } from './curveStartFinder.js';\nimport { GridRenderer } from './gridRenderer.js';\nimport { CurveRenderer } from './curveRenderer.js';\nimport { calculateAllHelperPoints } from './helperPointCalculator.js';\nimport { handleGridInteraction } from './interactionHandler.js';\nimport { calculateGridLayout } from './layoutManager.js';\n\nexport default class MirrorCurvesPlugin extends Plugin2D {\n    // Required static properties\n    static id = 'mirror-curves';\n    static name = 'Mirror Curves';\n    static description = 'Visualization of mirror curves based on grid reflections';\n    static renderingType = '2d'; // Using Konva for 2D rendering\n    \n    constructor(core) {\n        super(core);\n        \n        // Internal state\n        this.grid = null;\n        this.curves = [];\n        this.animationPath = null;\n        this.gridLayout = {};\n        this.helperPoints = [];\n        \n        // Animation state\n        this.isAnimating = false;\n        this.distanceTraveled = 0;\n        this.animationCurve = null;\n        this.animationQueue = [];\n        \n        // Rendering objects\n        this.gridRenderer = null;\n        this.curveRenderer = null;\n        \n        // Groups for organizing visualization elements\n        this.gridGroup = null;\n        this.staticCurveGroup = null;\n        this.animationGroup = null;\n        \n        // Track dirty states\n        this.isDirtyGrid = true;\n        this.isDirtyStaticCurves = true;\n        this.isDirtyAnimation = true;\n        \n        // For resize tracking\n        this.lastWidth = 0;\n        this.lastHeight = 0;\n    }\n    \n    async start() {\n        // Add visual parameters\n        this.addSlider('rows', 'Grid Rows', 5, { min: 2, max: 60, step: 1 });\n        this.addSlider('cols', 'Grid Columns', 5, { min: 2, max: 60, step: 1 });\n        this.addCheckbox('showGridLines', 'Show Grid Lines', true);\n        this.addCheckbox('showGridPoints', 'Show Grid Points', true);\n        this.addCheckbox('showMirrors', 'Show Mirrors', true);\n        this.addCheckbox('showCenterDots', 'Show Center Dots', false);\n        this.addColorPalette();\n\n        // Add structural parameters\n        this.addSlider('mirrorProbability', 'Mirror Probability', 0.5, { min: 0.1, max: 1, step: 0.1 }, 'structural');\n        this.addCheckbox('animateCurves', 'Animate Curves', true, 'structural');\n        this.addSlider('animationSpeed', 'Animation Speed', 15.0, \n                       { min: 1, max: 50, step: 1 }, 'structural');\n\n        // Add advanced parameters\n        this.addCheckbox('smooth', 'Smooth Curves', true, 'advanced');\n        this.addSlider('tension', 'Curve Smoothness', 0.01, { min: 0, max: 1, step: 0.1 }, 'advanced');\n        this.addDropdown('curveStyle', 'Curve Style', 'curved', ['curved', 'jagged'], 'advanced');\n        this.addCheckbox('showHelperPoints', 'Show Helper Points', false, 'advanced');\n        \n        // Add actions\n        this.addAction('randomize', 'Randomize Mirrors', () => this.randomizeMirrors());\n        this.addAction('findAllCurves', 'Find All Curves', () => this.discoverAllCurves());\n        this.addAction('clearCurves', 'Clear Curves', () => this.clearCurves());\n        this.addAction('animateCurve', 'Animate Next Curve', () => this.animateNextCurve());\n        \n        // Initialize the grid\n        this.initializeGrid();\n        \n        // Initialize renderers\n        this.gridRenderer = new GridRenderer(this.renderEnv.konva);\n        this.curveRenderer = new CurveRenderer(this.renderEnv.konva);\n        \n        // Set up Konva objects\n        this.setupKonvaObjects();\n        \n        // Start animation\n        this.animationHandler = this.requestAnimation(this.animate.bind(this));\n    }\n    \n    initializeGrid() {\n        const rows = this.getParameter('rows');\n        const cols = this.getParameter('cols');\n        \n        // Create a new grid\n        this.grid = new Grid(rows, cols);\n        \n        // Randomize mirrors with current probability\n        const probability = this.getParameter('mirrorProbability');\n        this.grid.randomizeMirrors(probability);\n        \n        // Reset curves AND animation state\n        this.curves = [];\n        this.animationPath = null;\n        this.helperPoints = [];\n        this.animationQueue = [];\n        this.isAnimating = false;\n        this.animationCurve = null;\n        this.distanceTraveled = 0;\n        \n        // Clear renderer cache if available\n        if (this.curveRenderer) {\n            this.curveRenderer.clearCache();\n        }\n        \n        // Mark everything as dirty to force redraw\n        this.isDirtyGrid = true;\n        this.isDirtyStaticCurves = true;\n        this.isDirtyAnimation = true;\n    }\n    \n    randomizeMirrors() {\n        if (!this.grid) return;\n        \n        const probability = this.getParameter('mirrorProbability');\n        this.grid.randomizeMirrors(probability);\n        \n        // Reset curves and animations when mirrors change\n        this.clearCurves();\n        this.isDirtyGrid = true;\n        this.updateStaticCurves();\n    }\n    \n    discoverAllCurves() {\n        if (!this.grid) return;\n        \n        // Find all remaining curves by repeatedly calling findNextCurve\n        const newCurves = [];\n        let nextCurve;\n        \n        while ((nextCurve = findNextCurve(this.grid)) !== null) {\n            newCurves.push(nextCurve);\n        }\n        \n        if (newCurves.length === 0) {\n            console.log('No new curves found');\n            return;\n        }\n        \n        console.log(`Found ${newCurves.length} new curves`);\n        \n        if (this.getParameter('animateCurves')) {\n            // Queue new curves for animation\n            this.animationQueue = [...this.animationQueue, ...newCurves];\n            \n            // Start animation if not already running\n            if (!this.isAnimating) {\n                this.startNextAnimation();\n            }\n        } else {\n            // Add all new curves at once without animation\n            newCurves.forEach(curve => {\n                curve.isCompleted = true;\n            });\n            this.curves = [...this.curves, ...newCurves];\n            this.updateHelperPoints();\n            this.isDirtyStaticCurves = true;\n        }\n    }\n    \n    clearCurves() {\n        this.curves = [];\n        this.animationPath = null;\n        this.helperPoints = [];\n        this.isAnimating = false;\n        this.animationCurve = null;\n        this.animationQueue = [];\n        this.distanceTraveled = 0;\n        \n        // Clear renderer cache\n        if (this.curveRenderer) {\n            this.curveRenderer.clearCache();\n        }\n        \n        // Reset used directions in the grid\n        if (this.grid) {\n            this.grid.resetUsedDirections();\n        }\n        \n        this.isDirtyStaticCurves = true;\n        this.isDirtyAnimation = true;\n    }\n    \n    updateHelperPoints() {\n        this.helperPoints = calculateAllHelperPoints(this.curves, this.gridLayout.cellSize);\n        this.isDirtyStaticCurves = true;\n    }\n\n    startNextAnimation() {\n        if (this.animationQueue.length === 0) {\n            this.isAnimating = false;\n            this.animationPath = null;\n            this.isDirtyAnimation = true;\n            return;\n        }\n        \n        // Get the next curve from the queue\n        this.animationCurve = this.animationQueue.shift();\n        \n        // Reset animation state\n        this.distanceTraveled = 0;\n        this.isAnimating = true;\n        this.isDirtyAnimation = true;\n        \n        // Clear any cache for the current animation curve\n        if (this.curveRenderer && this.animationCurve && this.animationCurve.gridLines[0]) {\n            const curveId = this.animationCurve.gridLines[0].id;\n            if (curveId) {\n                this.curveRenderer.clearCurveFromCache(curveId);\n            }\n        }\n    }\n    \n    animate(deltaTime) {\n        // Check if stage size has changed\n        const stage = this.renderEnv.stage;\n        const currentWidth = stage.width();\n        const currentHeight = stage.height();\n        \n        if (currentWidth !== this.lastWidth || currentHeight !== this.lastHeight) {\n            this.updateLayout();\n        }\n        \n        // Handle animation if active\n        if (this.isAnimating && this.animationCurve) {\n            // Calculate how much distance to travel this frame\n            const animationSpeed = this.getParameter('animationSpeed');\n            const distance = deltaTime * animationSpeed * 100; // Scale speed appropriately\n            this.distanceTraveled += distance;\n\n            // Create animation path based on distance traveled\n            this.animationPath = this.curveRenderer.createAnimationPathByDistance(\n                this.animationCurve, \n                this.gridLayout.cellSize, \n                this.distanceTraveled,\n                {\n                    tension: this.getParameter('tension'),\n                    curveStyle: this.getParameter('curveStyle'),\n                    gridRows: this.getParameter('rows'),\n                    gridCols: this.getParameter('cols')\n                }\n            );\n\n            // Mark animation layer as dirty to trigger redraw\n            this.isDirtyAnimation = true;\n\n            // Check if animation is complete\n            if (this.animationPath && this.animationPath.completed) {\n                // Add the completed curve to static curves\n                this.animationCurve.isCompleted = true;\n                this.curves.push(this.animationCurve);\n                \n                // Update helper points for all curves\n                this.updateHelperPoints();\n                \n                // Mark static curves as dirty to include the new curve\n                this.isDirtyStaticCurves = true;\n                \n                // Start the next animation if available\n                this.startNextAnimation();\n            }\n        }\n        \n        // Update animation layer if dirty\n        if (this.isDirtyAnimation) {\n            this.updateAnimation();\n            this.isDirtyAnimation = false;\n        }\n        \n        // Update static curves if needed\n        if (this.isDirtyStaticCurves) {\n            this.updateStaticCurves();\n            this.isDirtyStaticCurves = false;\n        }\n        \n        // Update grid if needed\n        if (this.isDirtyGrid) {\n            this.updateGrid();\n            this.isDirtyGrid = false;\n        }\n        \n        return true; // Continue animation\n    }\n    \n    setupKonvaObjects() {\n        // Create groups for different parts of the visualization\n        this.gridGroup = this.createGroup('grid');\n        this.staticCurveGroup = this.createGroup('main'); // Use 'main' layer for completed curves\n        this.animationGroup = this.createGroup('animation');\n        \n        // Mark all dirty to ensure initial render\n        this.isDirtyGrid = true;\n        this.isDirtyStaticCurves = true;\n        this.isDirtyAnimation = true;\n        \n        // Initial update\n        this.updateLayout();\n    }\n    \n    updateLayout() {\n        const stage = this.renderEnv.stage;\n        \n        // Get stage dimensions\n        const stageWidth = stage.width();\n        const stageHeight = stage.height();\n        \n        // Calculate layout\n        this.gridLayout = calculateGridLayout(\n            stageWidth,\n            stageHeight,\n            this.grid.rows,\n            this.grid.cols\n        );\n        \n        // Position groups\n        const { offsetX, offsetY } = this.gridLayout;\n        \n        this.gridGroup.position({ x: offsetX, y: offsetY });\n        this.staticCurveGroup.position({ x: offsetX, y: offsetY });\n        this.animationGroup.position({ x: offsetX, y: offsetY });\n        \n        // Clear curves when layout changes to prevent animation issues\n        this.clearCurves();\n        \n        // Store current dimensions\n        this.lastWidth = stageWidth;\n        this.lastHeight = stageHeight;\n        \n        // Mark all as dirty after layout change\n        this.isDirtyGrid = true;\n        this.isDirtyStaticCurves = true;\n        this.isDirtyAnimation = true;\n        \n        // Update all components with new layout\n        this.updateGrid();\n        this.updateStaticCurves();\n        this.updateAnimation();\n    }\n    \n    updateGrid() {\n        // Get colors from color scheme\n        const textColor = this.core.colorSchemeManager.getTextColor();\n        const mirrorColor = this.core.colorSchemeManager.getStructuralColor('strong');\n        \n        // Clear the grid group\n        this.gridGroup.destroyChildren();\n        \n        // Update grid visualization\n        this.gridRenderer.renderGrid(this.grid, this.gridGroup, {\n            cellSize: this.gridLayout.cellSize,\n            showGridLines: this.getParameter('showGridLines'),\n            showGridPoints: this.getParameter('showGridPoints'),\n            showMirrors: this.getParameter('showMirrors'),\n            showCenterDots: this.getParameter('showCenterDots'),\n            gridLineColor: textColor + '44', // Add transparency to text color for grid lines\n            mirrorColor: mirrorColor // Use strong color for mirrors\n        });\n        \n        // Draw the grid layer\n        this.redrawLayer('grid');\n    }\n    \n    updateStaticCurves() {\n        // Get color palette from color scheme manager\n        const selectedPalette = this.getParameter('colorPalette');\n        const colorPalette = this.core.colorSchemeManager.getPalette(selectedPalette);\n        const helperPointColor = this.core.colorSchemeManager.getAccentColor();\n        \n        // Clear the static curve group\n        this.staticCurveGroup.destroyChildren();\n        \n        // Render completed curves to static curve group\n        this.curveRenderer.renderCurves(this.curves, this.staticCurveGroup, {\n            cellSize: this.gridLayout.cellSize,\n            colorScheme: colorPalette,\n            curveStyle: this.getParameter('curveStyle'),\n            tension: this.getParameter('tension'),\n            smooth: this.getParameter('smooth'),\n            showHelperPoints: this.getParameter('showHelperPoints'),\n            helperPointColor: helperPointColor,\n            helperPoints: this.helperPoints,\n            gridRows: this.getParameter('rows'),\n            gridCols: this.getParameter('cols')\n        });\n        \n        // Draw the static curve layer\n        this.redrawLayer('main');\n    }\n    \n    updateAnimation() {\n        // Get color palette\n        const selectedPalette = this.getParameter('colorPalette');\n        const colorPalette = this.core.colorSchemeManager.getPalette(selectedPalette);\n        \n        // Clear the animation group\n        this.animationGroup.destroyChildren();\n        \n        // Only draw animation path if it exists\n        if (this.animationPath) {\n            // Use the same color as the static curve would have\n            let animationColor = colorPalette[this.curves.length % colorPalette.length];\n            \n            this.curveRenderer.renderCurves([], this.animationGroup, {\n                cellSize: this.gridLayout.cellSize,\n                colorScheme: [animationColor], // Use a single color for the animation\n                curveStyle: this.getParameter('curveStyle'),\n                tension: this.getParameter('tension'),\n                smooth: this.getParameter('smooth'),\n                animationPath: this.animationPath,\n                gridRows: this.getParameter('rows'),\n                gridCols: this.getParameter('cols')\n            });\n        }\n        \n        // Draw the animation layer\n        this.redrawLayer('animation');\n    }\n\n    animateNextCurve() {\n        if (!this.grid) {\n            console.warn('Grid not initialized');\n            return;\n        }\n        \n        // Find the next available curve\n        const nextCurve = findNextCurve(this.grid);\n        \n        if (nextCurve) {\n            console.log('Found next curve, queueing for animation');\n            \n            // Add curve to animation queue\n            this.animationQueue.push(nextCurve);\n            \n            // Start animation if not already running\n            if (!this.isAnimating) {\n                this.startNextAnimation();\n            }\n        } else {\n            console.log('No more curves available');\n        }\n    }\n    \n    onParameterChanged(parameterId, value) {\n        // Rebuild grid if rows or columns change\n        if (parameterId === 'rows' || parameterId === 'cols') {\n            this.initializeGrid();\n            this.updateLayout();\n            return;\n        }\n        \n        // Update grid if grid parameters change\n        if (parameterId === 'showGridLines' || parameterId === 'showGridPoints' || \n            parameterId === 'showMirrors' || parameterId === 'showCenterDots') {\n            this.isDirtyGrid = true;\n        }\n        \n        // Update static curves if curve style parameters change\n        if (parameterId === 'colorPalette' || parameterId === 'showHelperPoints' || \n            parameterId === 'tension' || parameterId === 'curveStyle' || \n            parameterId === 'smooth') {\n            this.isDirtyStaticCurves = true;\n            this.isDirtyAnimation = true;\n        }\n    }\n    \n    handleInteraction(type, data) {\n        // Handle clicks on grid lines to toggle mirrors\n        if (type === 'click' && this.grid) {\n            // Find the grid line that was clicked\n            const clickedLine = handleGridInteraction(this.grid, data, this.gridLayout);\n            \n            if (clickedLine) {\n                // Toggle mirror status\n                this.grid.setMirror(clickedLine.id, !clickedLine.isMirror);\n                \n                // Clear curves when mirrors change\n                this.clearCurves();\n                \n                // Mark grid as dirty\n                this.isDirtyGrid = true;\n            }\n        }\n    }\n    \n    async unload() {\n        // Cancel animations\n        if (this.animationHandler) {\n            this.cancelAnimation(this.animationHandler);\n        }\n        \n        // Reset state\n        this.grid = null;\n        this.curves = [];\n        this.animationPath = null;\n        this.gridLayout = {};\n        this.helperPoints = [];\n        this.isAnimating = false;\n        this.distanceTraveled = 0;\n        this.animationCurve = null;\n        this.animationQueue = [];\n        this.gridRenderer = null;\n        this.curveRenderer = null;\n        \n        // Let the base class handle cleanup of Konva objects\n        await super.unload();\n    }\n}\n","// plugins/mirror-curve/layoutManager.js\n\n/**\n * Calculate grid layout based on stage dimensions\n * @param {number} stageWidth - Width of the stage\n * @param {number} stageHeight - Height of the stage\n * @param {number} rows - Number of grid rows\n * @param {number} cols - Number of grid columns\n * @returns {Object} Layout parameters\n */\nexport function calculateGridLayout(stageWidth, stageHeight, rows, cols) {\n  // Calculate padding\n  const padding = Math.min(stageWidth, stageHeight) * 0.05;\n  \n  // Calculate drawable area\n  const drawableWidth = stageWidth - (padding * 2);\n  const drawableHeight = stageHeight - (padding * 2);\n  \n  // Calculate cell size to maintain square cells\n  const cellSize = Math.min(\n    drawableWidth / cols,\n    drawableHeight / rows\n  );\n  \n  // Calculate centering offsets\n  const offsetX = padding + (drawableWidth - (cellSize * cols)) / 2;\n  const offsetY = padding + (drawableHeight - (cellSize * rows)) / 2;\n  \n  return {\n    cellSize,\n    offsetX,\n    offsetY,\n    padding,\n    drawableWidth,\n    drawableHeight,\n    gridRows: rows,\n    gridCols: cols\n  };\n}\n\n/**\n * Apply layout transformations to Konva groups\n * @param {Object} gridGroup - Konva group for the grid\n * @param {Object} curveGroup - Konva group for the curves\n * @param {Object} layout - Layout parameters\n */\nexport function applyLayout(gridGroup, curveGroup, layout) {\n  const { offsetX, offsetY } = layout;\n  \n  // Position grid group\n  gridGroup.position({\n    x: offsetX,\n    y: offsetY\n  });\n  \n  // Position curve group to match grid\n  curveGroup.position({\n    x: offsetX,\n    y: offsetY\n  });\n}\n","// plugins/mirror-curve/interactionHandler.js\n\n/**\n * Handle interaction with the grid\n * @param {Object} grid - The grid object\n * @param {Object} event - Interaction event\n * @param {Object} gridLayout - Grid layout information\n * @returns {Object|null} The line that was clicked, or null\n */\nexport function handleGridInteraction(grid, event, gridLayout) {\n  if (!grid || !event || !gridLayout) {\n    return null;\n  }\n  \n  const { cellSize, offsetX, offsetY } = gridLayout;\n  const gridX = (event.x - offsetX) / cellSize;\n  const gridY = (event.y - offsetY) / cellSize;\n  \n  // Check if click is within grid boundaries\n  if (gridX >= 0 && gridX <= grid.cols && \n      gridY >= 0 && gridY <= grid.rows) {\n    \n    // Find the closest grid line\n    let closestLine = null;\n    let minDistance = Infinity;\n    \n    for (const line of grid.gridLines.values()) {\n      if (grid.isBoundaryGridLine(line)) {\n        // Skip boundary lines\n        continue;\n      }\n      \n      let distance;\n      if (line.type === 'horizontal') {\n        // For horizontal lines, check distance to y=row\n        const lineX1 = line.col * cellSize;\n        const lineX2 = (line.col + 1) * cellSize;\n        \n        // Check if x is within the line segment\n        if (gridX >= lineX1 / cellSize && gridX <= lineX2 / cellSize) {\n          distance = Math.abs(gridY - line.row);\n        } else {\n          continue;\n        }\n      } else { // vertical\n        // For vertical lines, check distance to x=col\n        const lineY1 = line.row * cellSize;\n        const lineY2 = (line.row + 1) * cellSize;\n        \n        // Check if y is within the line segment\n        if (gridY >= lineY1 / cellSize && gridY <= lineY2 / cellSize) {\n          distance = Math.abs(gridX - line.col);\n        } else {\n          continue;\n        }\n      }\n      \n      // Update closest line if this one is closer\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestLine = line;\n      }\n    }\n    \n    // Return the line if it's close enough\n    if (closestLine && minDistance < 0.2) {\n      return closestLine;\n    }\n  }\n  \n  return null;\n}\n","// src/core/BasePlugin.js\n\n/**\n * Abstract base plugin interface for the Math Visualization Framework\n * Provides common functionality independent of rendering environment\n */\nexport class BasePlugin {\n  /**\n   * Create a plugin instance\n   * @param {AppCore} core - Reference to the application core\n   */\n  constructor(core) {\n    // Get metadata from static properties\n    const metadata = this.constructor;\n    \n    // Ensure required properties are present in the class (static properties)\n    if (!metadata.id || !metadata.name || !metadata.renderingType) {\n      throw new Error(\"Plugin class must have static id, name, and renderingType properties\");\n    }\n    \n    // Add essential properties from static metadata to this instance\n    this.id = metadata.id;\n    this.name = metadata.name;\n    this.description = metadata.description || \"No description provided\";\n    this.renderingType = metadata.renderingType;\n    \n    // Store core reference\n    this.core = core;\n    \n    // Internal state\n    this.isLoaded = false;\n    this._eventHandlers = [];\n    this._animationHandlers = [];\n    \n    // Parameter tracking\n    this._visualParameters = [];\n    this._structuralParameters = [];\n    this._advancedParameters = [];\n  }\n  \n  /**\n   * Load and initialize the plugin - framework internal use\n   * @returns {Promise<boolean>} Whether loading was successful\n   */\n  async load() {\n    if (this.isLoaded) return true;\n    \n    try {\n      console.log(`Loading plugin: ${this.name} (${this.id})`);\n      \n      // Framework initialization steps\n      // Get the rendering environment at load time to ensure it's the correct one\n      this.renderEnv = this.core.getRenderingEnvironment();\n      \n      // Call the user-implemented start method\n      await this.start();\n      \n      this.isLoaded = true;\n      return true;\n    } catch (error) {\n      console.error(`Error loading plugin ${this.id}:`, error);\n      await this.unload();\n      return false;\n    }\n  }\n  \n  /**\n   * Start the plugin - main entry point for plugin developers\n   * Override this method to implement plugin-specific initialization\n   * @returns {Promise<void>}\n   */\n  async start() {\n    // To be implemented by subclasses\n    // This is where plugin developers should put their initialization code\n  }\n  \n  /**\n   * Unload and clean up the plugin\n   * @returns {Promise<boolean>} Whether unloading was successful\n   */\n  async unload() {\n    if (!this.isLoaded) return true;\n    \n    try {\n      console.log(`Unloading plugin: ${this.name} (${this.id})`);\n      \n      // Cancel all animations\n      this._cancelAllAnimations();\n      \n      // Remove all event handlers\n      this._removeAllEventHandlers();\n      \n      // Reset state\n      this.isLoaded = false;\n      this.renderEnv = null;\n      this._visualParameters = [];\n      this._structuralParameters = [];\n      this._advancedParameters = [];\n      \n      return true;\n    } catch (error) {\n      console.error(`Error unloading plugin ${this.id}:`, error);\n      return false;\n    }\n  }\n  \n  // ======== PARAMETER MANAGEMENT HELPER METHODS ========\n  \n  /**\n   * Add a slider parameter\n   * @param {string} id - Parameter ID\n   * @param {string} label - Display label\n   * @param {number} defaultValue - Default value\n   * @param {Object} options - Options like min, max, step\n   * @param {string} group - Parameter group ('visual', 'structural', 'advanced')\n   * @returns {BasePlugin} This plugin for chaining\n   */\n  addSlider(id, label, defaultValue, options = {}, group = 'visual') {\n    const param = {\n      id,\n      type: 'slider',\n      label,\n      default: defaultValue,\n      min: options.min !== undefined ? options.min : 0,\n      max: options.max !== undefined ? options.max : 100,\n      step: options.step !== undefined ? options.step : 1\n    };\n    \n    this._addParameter(param, group);\n    return this;\n  }\n  \n  /**\n   * Add a checkbox parameter\n   * @param {string} id - Parameter ID\n   * @param {string} label - Display label\n   * @param {boolean} defaultValue - Default value\n   * @param {string} group - Parameter group ('visual', 'structural', 'advanced')\n   * @returns {BasePlugin} This plugin for chaining\n   */\n  addCheckbox(id, label, defaultValue, group = 'visual') {\n    const param = {\n      id,\n      type: 'checkbox',\n      label,\n      default: defaultValue\n    };\n    \n    this._addParameter(param, group);\n    return this;\n  }\n  \n  /**\n   * Add a color picker parameter\n   * @param {string} id - Parameter ID\n   * @param {string} label - Display label\n   * @param {string} defaultValue - Default color value\n   * @param {string} group - Parameter group ('visual', 'structural', 'advanced')\n   * @returns {BasePlugin} This plugin for chaining\n   */\n  addColor(id, label, defaultValue, group = 'visual') {\n    const param = {\n      id,\n      type: 'color',\n      label,\n      default: defaultValue\n    };\n    \n    this._addParameter(param, group);\n    return this;\n  }\n\n  /**\n   * Add a color palette selector parameter\n   * @param {string} id - Parameter ID\n   * @param {string} label - Display label\n   * @param {string} group - Parameter group ('visual', 'structural', 'advanced')\n   * @returns {BasePlugin} This plugin for chaining\n   */\n  addColorPalette(id = 'colorPalette', label = 'Color Palette', group = 'visual') {\n    // Get palette information with both id and name\n    const paletteInfo = this.getPaletteInfo();\n    \n    // Get current palette name for default value\n    const currentPalette = this.getCurrentPaletteName();\n    \n    // Map palette info to dropdown options format\n    const options = paletteInfo.map(palette => ({\n      value: palette.id,\n      label: palette.name\n    }));\n    \n    // Add as a dropdown parameter\n    this.addDropdown(id, label, currentPalette, options, group);\n    \n    return this;\n  }\n  \n  /**\n   * Add a dropdown parameter\n   * @param {string} id - Parameter ID\n   * @param {string} label - Display label\n   * @param {string} defaultValue - Default selected value\n   * @param {Array} options - Array of options (strings or {value, label} objects)\n   * @param {string} group - Parameter group ('visual', 'structural', 'advanced')\n   * @returns {BasePlugin} This plugin for chaining\n   */\n  addDropdown(id, label, defaultValue, options, group = 'visual') {\n    const param = {\n      id,\n      type: 'dropdown',\n      label,\n      default: defaultValue,\n      options\n    };\n    \n    this._addParameter(param, group);\n    return this;\n  }\n  \n  /**\n   * Add a number input parameter\n   * @param {string} id - Parameter ID\n   * @param {string} label - Display label\n   * @param {number} defaultValue - Default value\n   * @param {Object} options - Options like min, max, step\n   * @param {string} group - Parameter group ('visual', 'structural', 'advanced')\n   * @returns {BasePlugin} This plugin for chaining\n   */\n  addNumber(id, label, defaultValue, options = {}, group = 'visual') {\n    const param = {\n      id,\n      type: 'number',\n      label,\n      default: defaultValue\n    };\n    \n    if (options.min !== undefined) param.min = options.min;\n    if (options.max !== undefined) param.max = options.max;\n    if (options.step !== undefined) param.step = options.step;\n    \n    this._addParameter(param, group);\n    return this;\n  }\n  \n  /**\n   * Add a text input parameter\n   * @param {string} id - Parameter ID\n   * @param {string} label - Display label\n   * @param {string} defaultValue - Default value\n   * @param {string} group - Parameter group ('visual', 'structural', 'advanced')\n   * @returns {BasePlugin} This plugin for chaining\n   */\n  addText(id, label, defaultValue, group = 'visual') {\n    const param = {\n      id,\n      type: 'text',\n      label,\n      default: defaultValue\n    };\n    \n    this._addParameter(param, group);\n    return this;\n  }\n  \n  /**\n   * Add a parameter to the appropriate group and register with core\n   * @param {Object} param - Parameter definition\n   * @param {string} group - Parameter group\n   * @private\n   */\n  _addParameter(param, group) {\n    // Store parameter locally for tracking\n    switch (group) {\n      case 'visual':\n        this._visualParameters.push(param);\n        break;\n      case 'structural':\n        this._structuralParameters.push(param);\n        break;\n      case 'advanced':\n        this._advancedParameters.push(param);\n        break;\n      default:\n        console.warn(`Unknown parameter group: ${group}, defaulting to visual`);\n        this._visualParameters.push(param);\n        group = 'visual';\n    }\n    \n    // Directly register the parameter with the core\n    const groupPrefix = group.charAt(0).toUpperCase() + group.slice(1);\n    const addMethodName = `addParameters${groupPrefix}`;\n    \n    if (this.core && typeof this.core[addMethodName] === 'function') {\n      this.core[addMethodName]([param]);\n    } else {\n      console.warn(`Cannot add parameter ${param.id} - no method available for group ${group}`);\n    }\n  }\n  \n  /**\n   * Remove a parameter\n   * @param {string} id - Parameter ID to remove\n   * @param {string} group - Optional parameter group\n   * @returns {boolean} Whether the parameter was found and removed\n   */\n  removeParameter(id, group = null) {\n    if (!this.core || typeof this.core.removeParameter !== 'function') {\n      console.warn('Core removeParameter method not available');\n      return false;\n    }\n    \n    // Use the core's removeParameter method\n    const result = this.core.removeParameter(id, group);\n    \n    if (result) {\n      // Update our internal tracking\n      const removeFromList = (list) => {\n        const index = list.findIndex(p => p.id === id);\n        if (index !== -1) {\n          list.splice(index, 1);\n          return true;\n        }\n        return false;\n      };\n      \n      if (group) {\n        // Remove from specific group\n        switch (group) {\n          case 'visual':\n            removeFromList(this._visualParameters);\n            break;\n          case 'structural':\n            removeFromList(this._structuralParameters);\n            break;\n          case 'advanced':\n            removeFromList(this._advancedParameters);\n            break;\n        }\n      } else {\n        // Remove from any group where it exists\n        removeFromList(this._visualParameters) || \n        removeFromList(this._structuralParameters) || \n        removeFromList(this._advancedParameters);\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Empty all parameters from the core\n   * @param {string} group - Optional parameter group to empty ('visual', 'structural', 'advanced')\n   * @returns {boolean} Whether the operation was successful\n   */\n  emptyParameters(group = null) {\n    // Clear all tracked parameters\n    if (!group) {\n      this._visualParameters = [];\n      this._structuralParameters = [];\n      this._advancedParameters = [];\n    } else {\n      // Clear only the specified group\n      switch (group) {\n        case 'visual':\n          this._visualParameters = [];\n          break;\n        case 'structural':\n          this._structuralParameters = [];\n          break;\n        case 'advanced':\n          this._advancedParameters = [];\n          break;\n        default:\n          console.warn(`Unknown parameter group: ${group}`);\n          return false;\n      }\n    }\n    \n    // Call the core method if available\n    if (this.core && typeof this.core.emptyParameters === 'function') {\n      return this.core.emptyParameters(group);\n    } else {\n      console.warn('Core emptyParameters method not available');\n      return false;\n    }\n  }\n  \n  /**\n   * Set a parameter value\n   * @param {string} id - Parameter ID\n   * @param {any} value - New value\n   * @returns {boolean} Whether the parameter was found and updated\n   */\n  setParameter(id, value) {\n    if (this.core && typeof this.core.changeParameter === 'function') {\n      return this.core.changeParameter(id, value);\n    }\n    return false;\n  }\n  \n  /**\n   * Get a parameter value\n   * @param {string} id - Parameter ID\n   * @returns {any} Parameter value or undefined if not found\n   */\n  getParameter(id) {\n    if (this.core && typeof this.core.getAllParameters === 'function') {\n      const params = this.core.getAllParameters();\n      return params[id];\n    }\n    return undefined;\n  }\n  \n  /**\n   * Get all parameter values\n   * @returns {Object} All parameter values\n   */\n  getAllParameters() {\n    if (this.core && typeof this.core.getAllParameters === 'function') {\n      return this.core.getAllParameters();\n    }\n    return {};\n  }\n  \n  // ======== ACTION MANAGEMENT HELPER METHODS ========\n  \n  /**\n   * Add an action\n   * @param {string} id - Action ID\n   * @param {string} label - Display label\n   * @param {Function} callback - Function to execute\n   * @param {Object} options - Additional options\n   * @returns {boolean} Whether the action was added successfully\n   */\n  addAction(id, label, callback, options = {}) {\n    if (this.core && typeof this.core.addAction === 'function') {\n      return this.core.addAction(id, label, callback, options);\n    }\n    return false;\n  }\n  \n  /**\n   * Remove an action\n   * @param {string} id - Action ID\n   * @returns {boolean} Whether the action was found and removed\n   */\n  removeAction(id) {\n    if (this.core && typeof this.core.removeAction === 'function') {\n      return this.core.removeAction(id);\n    }\n    return false;\n  }\n  \n  /**\n   * Refreshes the visualization without changing any state\n   * @protected - Internal use only, but available to subclasses\n   */\n  refresh() {\n    // To be implemented by subclasses\n  }\n  \n  // ======== ANIMATION HELPER METHODS ========\n  \n  /**\n   * Request animation\n   * @param {Function} callback - Animation callback function that receives deltaTime\n   * @returns {Function|null} Animation handler (for cancellation)\n   */\n  requestAnimation(callback) {\n    if (!this.core || !this.core.animationManager || \n        typeof this.core.animationManager.requestAnimation !== 'function') {\n      console.warn(\"Animation manager not available\");\n      return null;\n    }\n    \n    // Create animation handler\n    const handler = this.core.animationManager.requestAnimation(callback);\n    \n    // Store handler for cleanup\n    if (handler) {\n      this._animationHandlers.push(handler);\n    }\n    \n    return handler;\n  }\n  \n  /**\n   * Cancel animation\n   * @param {Function} handler - Animation handler to cancel\n   * @returns {boolean} Whether the animation was found and cancelled\n   */\n  cancelAnimation(handler) {\n    if (!this.core || !this.core.animationManager || \n        typeof this.core.animationManager.cancelAnimation !== 'function') {\n      return false;\n    }\n    \n    // Cancel animation\n    this.core.animationManager.cancelAnimation(handler);\n    \n    // Remove from our handlers list\n    const index = this._animationHandlers.indexOf(handler);\n    if (index !== -1) {\n      this._animationHandlers.splice(index, 1);\n      return true;\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Cancel all animations\n   * @private\n   */\n  _cancelAllAnimations() {\n    if (!this.core || !this.core.animationManager || \n        typeof this.core.animationManager.cancelAnimation !== 'function') {\n      return;\n    }\n    \n    // Cancel all animations\n    this._animationHandlers.forEach(handler => {\n      this.core.animationManager.cancelAnimation(handler);\n    });\n    \n    // Clear handlers list\n    this._animationHandlers = [];\n  }\n  \n  // ======== EVENT MANAGEMENT METHODS ========\n  \n  /**\n   * Handle parameter changes\n   * @param {string} parameterId - Parameter ID\n   * @param {any} value - New value\n   * @param {string} group - Parameter group\n   */\n  onParameterChanged(parameterId, value, group) {\n    // Implementation will be provided by subclasses\n  }\n  \n  /**\n   * Handle user interaction events\n   * @param {string} type - Type of interaction (mousedown, mousemove, mouseup, etc.)\n   * @param {Object} data - Interaction data\n   */\n  handleInteraction(type, data) {\n    // Implementation will be provided by subclasses\n  }\n  \n  /**\n   * Clean up event handlers\n   * @private\n   */\n  _removeAllEventHandlers() {\n    this._eventHandlers.forEach(handler => {\n      if (handler.target && handler.type && handler.callback) {\n        if (typeof handler.target.off === 'function') {\n          handler.target.off(handler.type, handler.callback);\n        }\n      } else if (handler.type === 'parameterChanged') {\n        this.core?.removeParameterCallback(handler.callback);\n      } else if (handler.type === 'action') {\n        this.core?.removeActionCallback(handler.callback);\n      } else if (handler.type === 'paletteChanged' && this.core?.events) {\n        this.core.events.off('paletteChanged', handler.callback);\n      }\n    });\n    \n    this._eventHandlers = [];\n  }\n\n  /**\n   * Internal method to handle parameter changes from AppCore\n   * This is called by AppCore but not directly exposed to plugin developers\n   * @param {string} parameterId - Parameter ID\n   * @param {any} value - New parameter value\n   * @param {string} group - Parameter group\n   */\n  _handleParameterChanged(parameterId, value, group) {\n    try {\n      // Call the user-defined onParameterChanged method\n      if (typeof this.onParameterChanged === 'function') {\n        this.onParameterChanged(parameterId, value, group);\n      }\n      \n      // Refresh visualization after parameter handling\n      this.refresh();\n    } catch (error) {\n      console.error(`Error handling parameter change in plugin ${this.id}:`, error);\n    }\n  }\n  \n  /**\n   * Internal method to handle action execution\n   * This is called by AppCore when an action button is pressed\n   * @param {string} actionId - ID of the action\n   * @param {Array} args - Arguments for the action\n   * @returns {any} Result of the action\n   */\n  _handleActionExecution(actionId, ...args) {\n    try {\n      // Find the action in the core\n      const action = this.core._actions.get(actionId);\n      \n      if (action && typeof action.callback === 'function') {\n        // Execute the action callback\n        const result = action.callback(...args);\n        \n        // Refresh visualization after action execution\n        this.refresh();\n        \n        return result;\n      }\n    } catch (error) {\n      console.error(`Error executing action ${actionId} in plugin ${this.id}:`, error);\n      \n      // Propagate error to UI if available\n      if (this.core && this.core.uiManager) {\n        this.core.uiManager.showError(`Action failed: ${error.message}`);\n      }\n    }\n    \n    return false;\n  }\n\n  // ======== COLOR SCHEME METHODS ========\n  /**\n   * Get a structural color from the current palette\n   * @param {string} element - Structural element name ('grid', 'weak', 'strong', 'guide', 'highlight')\n   * @returns {string} Color value\n   */\n  getStructuralColor(element) {\n    if (!this.core || !this.core.colorSchemeManager) {\n      return '#000000';\n    }\n    return this.core.colorSchemeManager.getStructuralColor(element);\n  }\n\n  /**\n   * Get a main color from the current palette by index\n   * @param {number} index - Main color index (0-based)\n   * @returns {string} Color value\n   */\n  getMainColor(index = 0) {\n    if (!this.core || !this.core.colorSchemeManager) {\n      return '#000000';\n    }\n    return this.core.colorSchemeManager.getMainColor(index);\n  }\n\n  /**\n   * Get all main colors from the current palette\n   * @returns {Array<string>} Array of main colors\n   */\n  getMainColors() {\n    if (!this.core || !this.core.colorSchemeManager) {\n      return [];\n    }\n    return this.core.colorSchemeManager.getMainColors();\n  }\n\n  /**\n   * Get a functional color from the current palette\n   * @param {string} purpose - Functional purpose ('positive', 'negative', 'neutral', 'selected', 'interactive')\n   * @returns {string} Color value\n   */\n  getFunctionalColor(purpose) {\n    if (!this.core || !this.core.colorSchemeManager) {\n      return '#000000';\n    }\n    return this.core.colorSchemeManager.getFunctionalColor(purpose);\n  }\n\n  /**\n   * Register to be notified of palette changes\n   * @param {Function} callback - Function to call when palette changes\n   */\n  onPaletteChanged(callback) {\n    if (!this.core || !this.core.events) return;\n    \n    this.core.events.on('paletteChanged', callback);\n    this._eventHandlers.push({\n      type: 'paletteChanged',\n      callback\n    });\n  }\n\n  /**\n   * Get available palette names and information\n   * @returns {Array<Object>} Array of palette info objects with id and name\n   */\n  getPaletteInfo() {\n    if (!this.core || !this.core.colorSchemeManager) {\n      return [];\n    }\n    return this.core.colorSchemeManager.getPaletteInfo();\n  }\n\n  /**\n   * Get the current palette name\n   * @returns {string} Current palette name\n   */\n  getCurrentPaletteName() {\n    if (!this.core || !this.core.colorSchemeManager) {\n      return 'default';\n    }\n    return this.core.colorSchemeManager.getCurrentPaletteName();\n  }\n\n  /**\n   * Set the current palette\n   * @param {string} paletteName - Palette name\n   * @returns {boolean} Whether the change was successful\n   */\n  setCurrentPalette(paletteName) {\n    if (!this.core || !this.core.colorSchemeManager) {\n      return false;\n    }\n    return this.core.colorSchemeManager.setCurrentPalette(paletteName);\n  }\n}\n"],"names":["Plugin2D","BasePlugin","constructor","core","super","this","renderingType","console","warn","concat","id","_shapes","Map","_groups","_eventBindings","_layers","background","grid","main","overlay","animation","_nextShapeId","getLayer","name","renderEnv","stage","error","existingLayer","getLayers","find","layer","konva","newLayer","Layer","insertionOrder","insertionIndex","indexOf","add","existingLayers","inserted","i","length","higherLayerName","higherLayer","l","moveToTop","_createUniqueId","_registerShape","shape","layerName","set","addShape","arguments","undefined","addGroup","group","_createShape","type","config","toLowerCase","Rect","Circle","Ellipse","Line","Path","Text","RegularPolygon","Star","Image","_objectSpread","closed","createGroup","createRect","createCircle","createLine","createPolygon","createText","createPath","createImage","Group","redrawLayer","batchDraw","redrawAllLayers","addEventHandler","eventType","handler","on","push","removeEventHandler","off","index","findIndex","binding","splice","refresh","unload","forEach","_ref","destroy","clear","_ref2","Grid","rows","cols","gridLines","usedDirections","initializeGridLines","computeConnections","placeBoundaryMirrors","initializeUsedDirections","row","col","generateGridLineId","isMirror","connections","NW","NE","SW","SE","setMirror","gridLine","values","entries","Set","isBoundaryGridLine","get","getGridLine","getAdjacentGridLine","lineId","direction","includes","nextLineId","Error","getReflectedDirection","gridLineId","incomingDirection","markDirectionUsed","has","isDirectionUsed","getUnusedDirections","allDirections","usedDirs","filter","dir","resetUsedDirections","isEdgeDirection","getMirrorCount","count","randomizeMirrors","p","log","parseGridLineId","Math","random","parts","split","parseInt","MirrorCurve","startGridLine","initialDirection","directions","isClosed","leftGrid","exitPoint","exitDirection","addSegment","nextGridLine","nextDirection","buildCurve","currentGridLine","currentDirection","oppositeDirection","message","toString","directionNames","result","findNextCurve","unusedDirections","curve","GridRenderer","styleSettings","lineStyles","width","gridPoint","radius","mirror","centerDot","renderGrid","options","cellSize","showGridLines","showGridPoints","showMirrors","showCenterDots","gridLineColor","mirrorColor","destroyChildren","line","x1","y1","x2","y2","lineObj","points","stroke","strokeWidth","r","c","circle","x","y","fill","mirrorLine","segmentSubdivision","P0","P1","M0","M1","subdivisions","pts","j","t","t2","t3","h00","h10","h01","h11","getSplinePoints","rawPoints","tension","N","slice","alreadyClosed","abs","effectivePoints","numPoints","tangents","prev","next","segment","findHelperPoint","d","calculateSubdivisions","cellCount","baseSubdivisions","max","CurveRenderer","helperPoint","animationCache","renderCurves","curves","colorScheme","curveStyle","smooth","showHelperPoints","helperPointColor","animationPath","helperPoints","gridRows","gridCols","idx","konvaCurve","createKonvaCurve","animCurve","helperPointRadius","curvePoints","point","Array","isArray","map","flatPoints","curveWidth","color","lineCap","lineJoin","createAnimationPathByDistance","distance","curveKey","allSplinePoints","totalLength","segmentLengths","cachedData","animSubdivisions","dx","dy","segmentLength","sqrt","completed","cappedDistance","min","currentLength","segmentIndex","visiblePoints","segmentFraction","lastPoint","nextPoint","interpPoint","clearCache","clearCurveFromCache","curveId","key","keys","startsWith","delete","MirrorCurvesPlugin","gridLayout","isAnimating","distanceTraveled","animationCurve","animationQueue","gridRenderer","curveRenderer","gridGroup","staticCurveGroup","animationGroup","isDirtyGrid","isDirtyStaticCurves","isDirtyAnimation","lastWidth","lastHeight","start","addSlider","step","addCheckbox","addColorPalette","addDropdown","addAction","discoverAllCurves","clearCurves","animateNextCurve","initializeGrid","setupKonvaObjects","animationHandler","requestAnimation","animate","bind","getParameter","probability","updateStaticCurves","newCurves","nextCurve","startNextAnimation","isCompleted","updateHelperPoints","allHelperPoints","helperPointsForCurve","curveIndex","calculateAllHelperPoints","shift","deltaTime","currentWidth","currentHeight","height","updateLayout","updateAnimation","updateGrid","stageWidth","stageHeight","padding","drawableWidth","drawableHeight","offsetX","offsetY","calculateGridLayout","position","textColor","colorSchemeManager","getTextColor","getStructuralColor","selectedPalette","colorPalette","getPalette","getAccentColor","animationColor","onParameterChanged","parameterId","value","handleInteraction","data","clickedLine","event","gridX","gridY","closestLine","minDistance","Infinity","lineX1","lineX2","lineY1","lineY2","handleGridInteraction","cancelAnimation","_defineProperty","description","metadata","isLoaded","_eventHandlers","_animationHandlers","_visualParameters","_structuralParameters","_advancedParameters","load","getRenderingEnvironment","_cancelAllAnimations","_removeAllEventHandlers","label","defaultValue","param","default","_addParameter","addColor","paletteInfo","getPaletteInfo","currentPalette","getCurrentPaletteName","palette","addNumber","addText","groupPrefix","charAt","toUpperCase","addMethodName","removeParameter","removeFromList","list","emptyParameters","setParameter","changeParameter","getAllParameters","callback","removeAction","animationManager","_this$core3","target","_this$core","removeParameterCallback","_this$core2","removeActionCallback","events","_handleParameterChanged","_handleActionExecution","actionId","action","_actions","_len","args","_key","uiManager","showError","element","getMainColor","getMainColors","getFunctionalColor","purpose","onPaletteChanged","setCurrentPalette","paletteName"],"sourceRoot":""}